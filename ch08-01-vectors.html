<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Vetores - A linguagem de programaÃ§Ã£o Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">ğŸ‡§ğŸ‡· A linguagem de programaÃ§Ã£o Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">ğŸ‡§ğŸ‡· PrefÃ¡cio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· ComeÃ§ando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Usando Structs para Estruturar Dados Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> ğŸ‡§ğŸ‡· Definindo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> ğŸ‡§ğŸ‡· Um Exemplo de um Programa que usa Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> ğŸ‡§ğŸ‡· Sintaxe do MÃ©todo</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> ğŸ‡§ğŸ‡· ColeÃ§Ãµes comuns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html" class="active"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸ‡§ğŸ‡· Um projeto de E/S</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸ‡§ğŸ‡· Aceitando Argumentos em Linha de Comando</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸ‡§ğŸ‡· Lendo um Arquivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸ‡§ğŸ‡· RefatoraÃ§Ã£o para Melhorar a Modularidade e o Tratamento de Erros</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸ‡§ğŸ‡· Desenvolvendo a Biblioteca de Funcionalidades</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸ‡§ğŸ‡· Trabalhando com VariÃ¡veis de Ambiente</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸ‡§ğŸ‡· Escrevendo Mensagens de Erro para Erro PadrÃ£o em Vez de SaÃ­da PadrÃ£o</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li class="chapter-item expanded "><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li class="chapter-item expanded "><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li class="chapter-item expanded "><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.6.</strong> ğŸ‡§ğŸ‡· G - Como Ã© feito o Rust e o &quot;Rust Nightly&quot;</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A linguagem de programaÃ§Ã£o Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#vetores" id="vetores">Vetores</a></h2>
<p>O primeiro tipo que iremos ver Ã© <code>Vec&lt;T&gt;</code>, tambÃ©m conhecido como <em>vetor</em>. Vetores
permitem guardar mais de um valor na mesma estrutura de dados que coloca todos
os valores um ao lado do outro na memÃ³ria. Vetores sÃ³ podem guardar valores do
mesmo tipo. Eles sÃ£o Ãºteis em situaÃ§Ãµes onde hÃ¡ uma lista de itens, como
as linha de texto em um arquivo ou preÃ§os de itens em um carrinho de compras.</p>
<h3><a class="header" href="#criando-um-novo-vetor" id="criando-um-novo-vetor">Criando um Novo Vetor</a></h3>
<p>Para criar um novo vetor, vazio, chamamos a funÃ§Ã£o <code>Vec::new</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p>Note que adicionamos uma anotaÃ§Ã£o de tipo aqui. Como nÃ£o estamos inserindo nenhum valor
no vetor, Rust nÃ£o sabe o tipo de elementos que irÃ¡ guardar.
Isto Ã© um ponto importante. Vetores sÃ£o homogÃªneos: eles podem guardar muitos 
valores, mas todos esses valores devem ser do mesmo tipo. Vetores sÃ£o implementados
usando genÃ©ricos, onde o capÃ­tulo 10 irÃ¡ cobrir como usar em seus tipos. Por
agora, tudo o que precisa saber Ã© que o tipo <code>Vec</code> fornecido pela biblioteca
padrÃ£o pode conter qualquer tipo, e quando um <code>Vec</code> especÃ­fico possui um tipo especÃ­fico, o
tipo vai dentro de <code>&lt; &gt;</code>. Falamos para Rust que <code>Vec</code> em <code>v</code> guardarÃ¡
elementos do tipo <code>i32</code>.</p>
<p>No cÃ³digo real, a Rust pode inferir o tipo de valor que queremos armazenar uma vez que inserimos
valores, entÃ£o vocÃª raramente precisa fazer essa anotaÃ§Ã£o de tipo. Ã‰ mais comum
criar um <code>Vec</code> que possui valores iniciais, e o Rust fornece a macro <code>vec!</code> por
conveniÃªncia. A macro criarÃ¡ um novo <code>Vec</code> que contÃ©m os valores que damos
. Isso criarÃ¡ um novo <code>Vec &lt;i32&gt;</code> que contÃ©m os valores <code>1</code>,<code> 2</code> e <code>3</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>Como nÃ³s damos valores iniciais  <code>i32</code>, Rust pode inferir que o tipo de <code>v</code>
Ã© <code>Vec &lt;i32&gt;</code>, e a anotaÃ§Ã£o de tipo nÃ£o Ã© necessÃ¡ria. Vejamos a seguir como
modificar um vetor.</p>
<h3><a class="header" href="#modificando-um-vetor" id="modificando-um-vetor">Modificando um Vetor</a></h3>
<p>Para criar um vetor e adicionar elementos a ele, podemos usar o mÃ©todo <code>push</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
<span class="boring">}
</span></code></pre></pre>
<p>Como qualquer variÃ¡vel que discutimos no CapÃ­tulo 3, se quisermos poder
alterar seu valor, precisamos fazÃª-lo mutÃ¡vel com a palavra-chave <code>mut</code>. Os 
nÃºmeros que inserimos sÃ£o todos do tipo <code>i32</code>, e Rust infere isso dos
dados, por isso nÃ£o precisamos da anotaÃ§Ã£o <code>Vec &lt;i32&gt;</code>.</p>
<h3><a class="header" href="#descartar-um-vetor-descarta-seus-elementos" id="descartar-um-vetor-descarta-seus-elementos">Descartar um Vetor Descarta seus Elementos</a></h3>
<p>Como qualquer outro <code>struct</code>, um vetor serÃ¡ liberado quando ele sair do escopo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let v = vec![1, 2, 3, 4];

    // use as informaÃ§Ãµes em v

} // &lt;- v sai do escopo e Ã© liberado aqui
<span class="boring">}
</span></code></pre></pre>
<p>Quando o vetor Ã© descartado, todos os seus conteÃºdos tambÃ©m serÃ¡ descartado, o que significa
esses inteiros que ele contÃ©m serÃ£o limpos. Isso pode parecer um
ponto direto, mas pode ficar um pouco mais complicado quando comeÃ§amos a
introduzir referÃªncias aos elementos do vetor. Vamos abordar isso em seguida!</p>
<h3><a class="header" href="#lendo-elementos-do-vetor" id="lendo-elementos-do-vetor">Lendo Elementos do Vetor</a></h3>
<p>Agora que vocÃª sabe como criar, atualizar e destruir vetores, 
saber ler o seu conteÃºdo Ã© um bom passo seguinte. Existem duas maneiras de fazer referÃªncia a
valores armazenados em um vetor. Nos exemplos, anotamos os tipos de
valores que sÃ£o retornados dessas funÃ§Ãµes para maior clareza.</p>
<p>Este exemplo mostra os dois mÃ©todos de acesso a um valor em um vetor com
sintaxe de indexaÃ§Ã£o ou o mÃ©todo <code>get</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
<span class="boring">}
</span></code></pre></pre>
<p>HÃ¡ algumas coisas a serem observadas aqui. Primeiro, que usamos o valor do Ã­ndice de <code>2</code>
para obter o terceiro elemento: os vetores sÃ£o indexados por nÃºmero, comeÃ§ando em zero.
Em segundo lugar, as duas maneiras diferentes de obter o terceiro elemento sÃ£o: usando <code>&amp;</code> e
<code>[]</code>, que nos dÃ¡ uma referÃªncia, ou usando o mÃ©todo <code>get</code> com o Ã­ndice
passado como um argumento, o que nos dÃ¡ uma <code>Option&lt;&amp;T&gt;</code>.</p>
<p>A razÃ£o pela qual Rust tem duas maneiras de fazer referÃªncia a um elemento Ã© para que vocÃª possa escolher
como o programa se comporta quando vocÃª tenta usar um valor de Ã­ndice para o qual 
o vetor nÃ£o tem um elemento correspondente. Por exemplo, o que um programa deve fazer se tiver
um vetor que contÃ©m cinco elementos, entÃ£o tenta acessar um elemento no Ã­ndice 100
dessa maneira:</p>
<pre><pre class="playground"><code class="language-rust should_panic">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p>Quando vocÃª executar isso, vocÃª verÃ¡ que com o primeiro mÃ©todo <code>[]</code>, Rust irÃ¡
causar um <code>panic!</code> quando um elemento inexistente Ã© referenciado. Este mÃ©todo seria
preferÃ­vel se vocÃª quiser que seu programa considere uma tentativa de acessar um
elemento, passado o fim do vetor, para ser um erro fatal que deve finalizar o
programa.</p>
<p>Quando Ã© passado um Ã­ndice que estÃ¡ fora da matriz para o mÃ©todo <code>get</code>, ele 
retorna <code>None</code> sem entrar em pÃ¢nico. VocÃª usaria isso se acessar um elemento
alÃ©m do alcance do vetor ocorrerÃ¡ ocasionalmente sob 
circunstÃ¢ncias normais. Seu cÃ³digo pode entÃ£o ter lÃ³gica para lidar tanto com
<code>Some(&amp;element)</code> ou <code>None</code>, como discutimos no CapÃ­tulo 6. Por exemplo, o
O Ã­ndice pode ser proveniente de uma pessoa que digite um nÃºmero. Se eles acidentalmente
insira um nÃºmero que Ã© muito grande e seu programa recebe um valor <code>None</code>, vocÃª poderia
dizer ao usuÃ¡rio quantos itens estÃ£o no atual <code>Vec</code> e dar uma nova
chance de inserir um valor vÃ¡lido. Isso seria mais amigÃ¡vel do que quebrar o
programa por um erro de digitaÃ§Ã£o!</p>
<h4><a class="header" href="#referÃªncias-invÃ¡lidas" id="referÃªncias-invÃ¡lidas">ReferÃªncias InvÃ¡lidas</a></h4>
<p>Uma vez que o programa tenha uma referÃªncia vÃ¡lida, o verificador de emprÃ©stimo (borrow checker) faz valer
as regras de propriedade e emprÃ©stimo abrangidas no CapÃ­tulo 4 para garantir que essa referÃªncia e
quaisquer outras referÃªncias aos conteÃºdos do vetor permaneÃ§am vÃ¡lidas. Lembre-se da regra
que diz que nÃ£o podemos ter referÃªncias mutÃ¡veis e imutÃ¡veis no mesmo escopo.
Essa regra se aplica neste exemplo, onde mantemos uma referÃªncia imutÃ¡vel ao
primeiro elemento em um vetor e tentamos adicionar um elemento ao final:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p>Compilar isso nos darÃ¡ esse erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
  |
4 | let first = &amp;v[0];
  |              - immutable borrow occurs here
5 |
6 | v.push(6);
  | ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Este cÃ³digo pode parecer que deveria funcionar: por que uma referÃªncia ao primeiro
elemento deveria se preocupar com o que muda sobre o final do vetor? A razÃ£o porque
este cÃ³digo nÃ£o Ã© permitido Ã© devido Ã  forma como os vetores funcionam. Adicionando um novo elemento
no final do vetor pode exigir a atribuiÃ§Ã£o de nova alocaÃ§Ã£o de memÃ³ria e copiar os
elementos antigos para o novo espaÃ§o, na circunstÃ¢ncia de nÃ£o haver espaÃ§o suficiente
para colocar todos os elementos prÃ³ximos um do outro onde o vetor estava. Nesse
caso, a referÃªncia ao primeiro elemento apontaria para memÃ³ria nÃ£o alocada.
As regras de emprÃ©stimo impedem que os programas acabem nessa situaÃ§Ã£o.</p>
<blockquote>
<p>Nota: para mais informaÃ§Ãµes, veja o Rustonomicon em
<em>https://doc.rust-lang.org/stable/nomicon/vec.html</em>.</p>
</blockquote>
<h3><a class="header" href="#usando-um-enum-para-armazenar-vÃ¡rios-tipos" id="usando-um-enum-para-armazenar-vÃ¡rios-tipos">Usando um Enum para Armazenar VÃ¡rios Tipos</a></h3>
<p>No inÃ­cio deste capÃ­tulo, dissemos que os vetores sÃ³ podem armazenar valores
que sÃ£o todos do mesmo tipo. Isso pode ser inconveniente; definitivamente hÃ¡ casos 
de uso para a necessidade de armazenar uma lista de coisas de diferentes tipos. Felizmente,
as variantes de um enum sÃ£o todas definidas sob o mesmo tipo de enum, entÃ£o, quando precisamos
armazenar elementos de um tipo diferente em um vetor, podemos definir e usar um
enum!</p>
<p>Por exemplo, digamos que queremos obter valores de uma linha em uma planilha, onde
algumas das colunas da linha contÃªm nÃºmeros inteiros, alguns nÃºmeros de ponto flutuante,
e algumas strings. Podemos definir um enum cujas variantes guardarÃ£o os diferentes
tipos de valor, e entÃ£o todas as variantes de enum serÃ£o consideradas do mesmos
tipo, o do enum. EntÃ£o, podemos criar um vetor que contenha esse enum e
entÃ£o, em Ãºltima instÃ¢ncia, possui diferentes tipos:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listagem 8-1: Definindo um enum para poder guardar
diferentes tipos de dados em um vetor</span></p>
<p>A razÃ£o pela qual Rust precisa saber exatamente quais tipos estarÃ£o no vetor em
tempo de compilaÃ§Ã£o Ã© para que ele saiba exatamente a quantidade de memÃ³ria no heap que serÃ¡
necessÃ¡ria para armazenar cada elemento. Uma vantagem secundÃ¡ria para isso Ã© que podemos ser
explÃ­citos sobre quais tipos sÃ£o permitidos neste vetor. Se Rust permitisse um vetor
guardar qualquer tipo, haveria uma chance de que um ou mais dos tipos
causar erros com as operaÃ§Ãµes realizadas nos elementos do vetor. Usando
um enum mais um <code>match</code> significa que a Rust garantirÃ¡ no tempo de compilaÃ§Ã£o que nÃ³s
sempre lidaremos com todos os casos possÃ­veis, como discutimos no CapÃ­tulo 6.</p>
<p>Se vocÃª nÃ£o sabe no momento em que vocÃª estÃ¡ escrevendo um programa, o conjunto exaustivo
dos tipos que o programa irÃ¡ precisar no tempo de execuÃ§Ã£o para armazenar em um vetor, a tÃ©cnica de usar
o enum nÃ£o funcionarÃ¡. Em vez disso, vocÃª pode usar um objeto trait, que abordaremos no
CapÃ­tulo 17.</p>
<p>Agora que examinamos algumas das maneiras mais comuns de usar vetores, certifique-se
para dar uma olhada na documentaÃ§Ã£o da API para todos os muitos mÃ©todos Ãºteis
definidos no <code>Vec</code> pela biblioteca padrÃ£o. Por exemplo, alÃ©m de <code>push</code>
existe um mÃ©todo <code>pop</code> que irÃ¡ remover e retornar o Ãºltimo elemento. Vamos mover
para o prÃ³ximo tipo de coleÃ§Ã£o: <code>String</code>!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch08-00-common-collections.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch08-02-strings.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch08-00-common-collections.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch08-02-strings.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
