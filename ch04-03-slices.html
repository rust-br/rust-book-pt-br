<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Slices - A linguagem de programaÃ§Ã£o Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">ğŸ‡§ğŸ‡· A linguagem de programaÃ§Ã£o Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">ğŸ‡§ğŸ‡· PrefÃ¡cio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· ComeÃ§ando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html" class="active"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Usando Structs para Estruturar Dados Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> ğŸ‡§ğŸ‡· Definindo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> ğŸ‡§ğŸ‡· Um Exemplo de um Programa que usa Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> ğŸ‡§ğŸ‡· Sintaxe do MÃ©todo</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> ğŸ‡§ğŸ‡· ColeÃ§Ãµes comuns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸ‡§ğŸ‡· Um projeto de E/S</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸ‡§ğŸ‡· Aceitando Argumentos em Linha de Comando</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸ‡§ğŸ‡· Lendo um Arquivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸ‡§ğŸ‡· RefatoraÃ§Ã£o para Melhorar a Modularidade e o Tratamento de Erros</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸ‡§ğŸ‡· Desenvolvendo a Biblioteca de Funcionalidades</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸ‡§ğŸ‡· Trabalhando com VariÃ¡veis de Ambiente</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸ‡§ğŸ‡· Escrevendo Mensagens de Erro para Erro PadrÃ£o em Vez de SaÃ­da PadrÃ£o</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li class="chapter-item expanded "><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li class="chapter-item expanded "><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li class="chapter-item expanded "><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.6.</strong> ğŸ‡§ğŸ‡· G - Como Ã© feito o Rust e o &quot;Rust Nightly&quot;</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A linguagem de programaÃ§Ã£o Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#slices" id="slices"><em>Slices</em></a></h2>
<p>Outro tipo de dados em que nÃ£o hÃ¡ ownership Ã© a <em>slice</em> (do inglÃªs, fatia).
Slices lhe permitem referenciar uma sequÃªncia contÃ­gua de elementos em uma
coleÃ§Ã£o em vez de referenciar a coleÃ§Ã£o inteira.</p>
<p>Aqui estÃ¡ um pequeno problema de programaÃ§Ã£o: escrever uma funÃ§Ã£o que pega uma
string e retorna a primeira palavra que encontrar dentro dela. Se a funÃ§Ã£o nÃ£o
encontrar um espaÃ§o na string, significa que a string inteira Ã© uma palavra sÃ³,
entÃ£o a string toda deve ser retornada.</p>
<p>Vamos pensar sobre a assinatura desta funÃ§Ã£o:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; ?
</code></pre>
<p>Esta funÃ§Ã£o, <code>primeira_palavra</code>, tem uma <code>&amp;String</code> como parÃ¢metro. NÃ³s nÃ£o
queremos tomar posse dela, entÃ£o tudo bem. Mas o que nÃ³s deverÃ­amos retornar?
NÃ£o temos uma forma de falar sobre <em>parte</em> de uma string. No entanto, poderÃ­amos
retornar o Ã­ndice do final de uma palavra. Vamos tentar fazer isso, conforme
mostrado na Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn primeira_palavra(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listagem 4-5: A funÃ§Ã£o <code>primeira_palavra</code>, que retorna um
Ã­ndice para um byte da <code>String</code> passada como parÃ¢metro.</span></p>
<p>Vamos dividir este cÃ³digo em algumas partes. Como precisamos varrer a <code>String</code>
elemento por elemento, e verificar se algum valor Ã© um espaÃ§o, vamos converter
nossa <code>String</code> em um array de bytes usando o mÃ©todo <code>as_bytes</code>:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>Depois, criamos um iterador sobre o array de bytes usando o mÃ©todo <code>iter</code>:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>Vamos discutir sobre iteradores em mais detalhes no CapÃ­tulo 13. Por enquanto,
saiba que <code>iter</code> Ã© um mÃ©todo que retorna cada elemento em uma coleÃ§Ã£o, e
<code>enumerate</code> encapsula o resultado do <code>iter</code> e retorna cada elemento como parte
de uma tupla. O primeiro elemento da tupla Ã© o Ã­ndice, e o segundo elemento Ã©
uma referÃªncia ao valor. Isto Ã© um pouco mais conveniente do que calcular o
Ã­ndice nÃ³s mesmos.</p>
<p>Como o mÃ©todo <code>enumerate</code> retorna uma tupla, podemos usar padrÃµes para
desestruturar esta tupla, assim como qualquer outra coisa em Rust. EntÃ£o, no
<code>for</code>, especificamos um padrÃ£o que tem <code>i</code> para o Ã­ndice na tupla e <code>&amp;item</code> para
o byte. Como pegamos uma referÃªncia ao elemento atravÃ©s do
<code>.iter().enumerate()</code>, usamos um <code>&amp;</code> neste padrÃ£o.</p>
<p>NÃ³s procuramos o byte que representa um espaÃ§o usando a sintaxe de byte literal.
Se encontrarmos um espaÃ§o, retornamos a posiÃ§Ã£o dele. Caso contrÃ¡rio, retornamos
o tamanho da string usando <code>s.len()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}
s.len()
</code></pre>
<p>Agora temos uma forma de descobrir o Ã­ndice do fim da primeira palavra na
string, mas tem um problema. Estamos retornando um <code>usize</code> por si sÃ³, mas ele sÃ³
possui um significado no contexto da <code>&amp;String</code>. Em outras palavras, como Ã© um
valor separado da <code>String</code>, nÃ£o hÃ¡ garantia de que ele ainda serÃ¡ vÃ¡lido no
futuro. Considere o programa na Listagem 4-6, que usa a funÃ§Ã£o da Listagem 4-5:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn primeira_palavra(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = primeira_palavra(&amp;s); // palavra vai ter o valor 5.

    s.clear(); // Isso esvazia a String, deixando ela igual a &quot;&quot;.

    // palavra ainda tem o valor 5 aqui, mas jÃ¡ nÃ£o hÃ¡ mais uma string para a
    // qual o valor 5 faÃ§a algum sentido. palavra agora Ã© totalmente invÃ¡lida!
}
</code></pre></pre>
<p><span class="caption">Listagem 4-6: Armazenando o resultado de uma chamada Ã 
funÃ§Ã£o <code>primeira_palavra</code>, e depois, mudando o conteÃºdo da <code>String</code>.</span></p>
<p>Este programa compila sem erros, e tambÃ©m o faria se usÃ¡ssemos a variÃ¡vel
<code>palavra</code> depois de chamar <code>s.clear()</code>. <code>palavra</code> nÃ£o estÃ¡ conectada ao estado
de <code>s</code> de nenhuma forma, entÃ£o, <code>palavra</code> ainda contÃ©m o valor <code>5</code>. PoderÃ­amos
usar esse valor <code>5</code> com a variÃ¡vel <code>s</code> para tentar extrair a primeira palavra da
string, mas isso seria um bug, pois o conteÃºdo de <code>s</code> jÃ¡ mudou apÃ³s termos salvo
o valor <code>5</code> na variÃ¡vel <code>word</code>.</p>
<p>Ter que se preocupar sobre o Ã­ndice da <code>palavra</code> ficar fora de sincronia com os
dados em <code>s</code> Ã© tedioso e propenso a erros! Gerenciar esses Ã­ndices Ã© ainda mais
delicado se escrevermos uma funÃ§Ã£o <code>segunda_palavra</code>. Sua assinatura teria que
ser algo do tipo:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Agora estamos rastreando os Ã­ndices do inÃ­cio <em>e</em> do final, e temos ainda mais
valores que sÃ£o calculados a partir dos dados em um estado particular, mas que
nÃ£o estÃ£o vinculados a este estado de nenhuma forma. Agora temos trÃªs variÃ¡veis
nÃ£o relacionadas flutuando que precisam ser mantidas em sincronia.</p>
<p>Felizmente, Rust possui uma soluÃ§Ã£o para este problema: slices de string.</p>
<h3><a class="header" href="#slices-de-string" id="slices-de-string">Slices de String</a></h3>
<p>Uma <em>slice de string</em> Ã© uma referÃªncia para uma parte de uma <code>String</code>, e tem a
seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;texto longo&quot;);

let texto = &amp;s[0..5];
let longo = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>Isto Ã© similar a pegar uma referÃªncia Ã  <code>String</code> inteira, mas com um <code>[0..5]</code> a
mais. Em vez de uma referÃªncia Ã  <code>String</code> inteira, trata-se de uma referÃªncia a
uma porÃ§Ã£o da <code>String</code>. A sintaxe <code>inÃ­cio..fim</code> representa um <em>range</em>
(uma faixa) que comeÃ§a em <code>inÃ­cio</code> e continua atÃ©, mas nÃ£o incluindo, <code>fim</code>.</p>
<p>Podemos criar slices usando um range entre colchetes especificando
<code>[Ã­ndice_inicial..Ã­ndice_final]</code>, em que <code>Ã­ndice_inicial</code> Ã© a primeira posiÃ§Ã£o
inclusa na slice, e <code>Ã­ndice_final</code> Ã© um a mais que a Ãºltima posiÃ§Ã£o inclusa na
slice. Internamente, a estrutura de dados de uma slice armazena a posiÃ§Ã£o
inicial e o tamanho da slice, que corresponde a <code>Ã­ndice_final</code> menos
<code>Ã­ndice_inicial</code>. EntÃ£o, no caso do <code>let longo = &amp;s[6..11];</code>, <code>longo</code> seria uma
slice que contÃ©m um ponteiro para o sÃ©timo byte de <code>s</code> (Ã­ndice 6) e um tamanho
igual a 5.</p>
<p>A Figura 4-6 mostra isto em um diagrama.</p>
<img alt="mundo contendo um ponteiro para o 7o byte da String s e um tamanho 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figura 4-6: Slice referente a uma parte de uma
<code>String</code></span></p>
<p>Com a sintaxe de range do Rust (<code>..</code>), se vocÃª quiser comeÃ§ar com o primeiro
elemento (Ã­ndice zero), vocÃª pode omitir o valor antes dos dois pontos. Em
outras palavras, estas formas sÃ£o equivalentes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;texto&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>Da mesma forma, se a sua slice inclui o Ãºltimo byte da <code>String</code>, vocÃª pode
omitir o Ãºltimo nÃºmero. Isso significa que as seguintes formas sÃ£o equivalentes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[3..tamanho];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>VocÃª tambÃ©m pode omitir ambos os valores para pegar uma slice da string inteira.
Logo, essas duas formas sÃ£o equivalentes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;texto&quot;);

let tamanho = s.len();

let slice = &amp;s[0..tamanho];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Nota: Os Ã­ndices do range de uma slice de string devem coincidir com os
limites entre caracteres UTF-8 vÃ¡lidos. Se vocÃª tentar criar uma slice de
string no meio de um caractere que tenha mais de um byte, seu programa vai
terminar com erro. Para introduzir slices de string, estamos utilizando
apenas caracteres ASCII nesta seÃ§Ã£o; uma discussÃ£o mais detalhada sobre
manipulaÃ§Ã£o de caracteres UTF-8 serÃ¡ feita na seÃ§Ã£o &quot;Strings&quot; do CapÃ­tulo 8.</p>
</blockquote>
<p>Com toda essa informaÃ§Ã£o em mente, vamos reescrever a funÃ§Ã£o <code>primeira_palavra</code>
para retornar uma slice. O tipo que representa &quot;slice de string&quot; Ã© escrito como
<code>&amp;str</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}
</span></code></pre></pre>
<p>Pegamos o Ã­ndice para o fim da palavra da mesma forma como fizemos na Listagem
4-5, buscando a primeira ocorrÃªncia de um espaÃ§o. Quando o encontramos,
retornamos uma slice de string usando o inÃ­cio da string e o Ã­ndice do espaÃ§o
como Ã­ndices inicial e final, respectivamente.</p>
<p>Agora, quando chamamos <code>primeira_palavra</code>, pegamos de volta um Ãºnico valor que
estÃ¡ vinculado Ã  string. O valor Ã© composto de uma referÃªncia para o ponto
inicial da slice e o nÃºmero de elementos que ela contÃ©m.</p>
<p>Retornar uma slice tambÃ©m funcionaria para uma funÃ§Ã£o <code>segunda_palavra</code>:</p>
<pre><code class="language-rust ignore">fn segunda_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Agora, temos uma API bem direta que Ã© bem mais difÃ­cil de bagunÃ§ar, uma vez que
o compilador vai se certificar que as referÃªncias dentro da <code>String</code>
permanecerÃ£o vÃ¡lidas. Lembra do bug do programa na Listagem 4-6, quando
obtivemos o Ã­ndice para o fim da primeira palavra mas depois limpamos a string,
invalidando o Ã­ndice obtido? Aquele cÃ³digo era logicamente incorreto, mas nÃ£o
mostrava nenhum erro imediato. Os problemas apareceriam mais tarde quando
tentÃ¡ssemos usar o Ã­ndice da primeira palavra com uma string que foi esvaziada.
Slices tornam esse bug impossÃ­vel de acontecer e nos permitem saber que temos um
problema no cÃ³digo muito mais cedo. Na versÃ£o usando slice, a funÃ§Ã£o
<code>primeira_palavra</code> vai lanÃ§ar um erro em tempo de compilaÃ§Ã£o:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;texto longo&quot;);

    let palavra = first_word(&amp;s);

    s.clear(); // Erro!
}
</code></pre>
<p>Aqui estÃ¡ o erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let word = primeira_palavra(&amp;s);
  |                                  - immutable borrow occurs here
5 |
6 |     s.clear(); // Erro!
  |     ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Voltando Ã s regras de borrowing, lembre-se que, se temos uma referÃªncia imutÃ¡vel
para algum valor, nÃ£o podemos tambÃ©m obter uma referÃªncia mutÃ¡vel do mesmo. Como
<code>clear</code> precisa truncar a <code>String</code>, esse mÃ©todo tenta obter uma referÃªncia
mutÃ¡vel, e acaba falhando. O Rust nÃ£o sÃ³ tornou nossa API mais fÃ¡cil de usar,
como tambÃ©m eliminou uma classe inteira de erros em tempo de compilaÃ§Ã£o!</p>
<h4><a class="header" href="#strings-literais-sÃ£o-slices" id="strings-literais-sÃ£o-slices">Strings Literais SÃ£o Slices</a></h4>
<p>Lembre-se de que falamos sobre strings literais serem armazenadas dentro do
binÃ¡rio. Agora que conhecemos slices, podemos entender strings literais
adequadamente:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;OlÃ¡, mundo!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>O tipo de <code>s</code> aqui Ã© <code>&amp;str</code>: Ã© uma slice apontando para aquele ponto especÃ­fico
do binÃ¡rio. TambÃ©m Ã© por isso que strings literais sÃ£o imutÃ¡veis; <code>&amp;str</code> Ã© uma
referÃªncia imutÃ¡vel.</p>
<h4><a class="header" href="#slices-de-strings-como-parÃ¢metros" id="slices-de-strings-como-parÃ¢metros">Slices de Strings como ParÃ¢metros</a></h4>
<p>Saber que vocÃª pode obter slices de literais e <code>String</code>s nos levam a mais um
aprimoramento da funÃ§Ã£o <code>primeira_palavra</code>, e aqui estÃ¡ sua assinatura:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Um RustÃ¡ceo mais experiente escreveria esta funÃ§Ã£o conforme a seguir, permitindo
utilizar a mesma funÃ§Ã£o com <code>String</code>s e <code>&amp;str</code>s:</p>
<pre><code class="language-rust ignore">fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Se temos uma slice de string, podemos passÃ¡-la diretamente. Se temos uma
<code>String</code>, podemos passar uma slice da <code>String</code> inteira. Definir uma funÃ§Ã£o que
recebe uma slice em vez de uma referÃªncia para uma String deixa nossa API mais
genÃ©rica e Ãºtil sem perder nenhuma funcionalidade:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn primeira_palavra(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span>fn main() {
    let minha_string = String::from(&quot;texto longo&quot;);

    // primeira_palavra funciona com slices de `String`s
    let palavra = primeira_palavra(&amp;minha_string[..]);

    let minha_string_literal = &quot;texto longo&quot;;

    // primeira_palavra funciona com strings literais
    let palavra = primeira_palavra(&amp;minha_string_literal[..]);
	
	// uma vez que strings literais *sÃ£o* slices de strings,
	// isso tambÃ©m funciona, sem nem usar sintaxe de slice!
    let palavra = primeira_palavra(minha_string_literal);
}
</code></pre></pre>
<h3><a class="header" href="#outras-slices" id="outras-slices">Outras Slices</a></h3>
<p>Slices de string, como vocÃª pode imaginar, sÃ£o especÃ­ficas de strings. Mas hÃ¡
tambÃ©m um tipo de slice mais genÃ©rico. Considere esta array:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Assim como Ã s vezes queremos nos referir a uma parte de uma string, podemos
tambÃ©m querer nos referir a uma parte de uma array, e farÃ­amos isso da seguinte
forma:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<p>Essa slice tem o tipo <code>&amp;[i32]</code>. Ela funciona da mesma forma que as slices de
string, armazenando uma referÃªncia para o primeiro elemento e um tamanho. VocÃª
vai usar esse tipo de slice para todos os tipos de coleÃ§Ãµes. Vamos discutir
essas coleÃ§Ãµes em mais detalhe quando falarmos sobre vetores no CapÃ­tulo 8.</p>
<h2><a class="header" href="#resumo" id="resumo">Resumo</a></h2>
<p>Os conceitos de ownership, borrowing, e slices sÃ£o o que garante a seguranÃ§a de
memÃ³ria dos programas em Rust em tempo de compilaÃ§Ã£o. A linguagem Rust lhe dÃ¡
controle sobre o uso da memÃ³ria, assim como outras linguagens de programaÃ§Ã£o de
sistemas, mas como o dono dos dados limpa automaticamente a memÃ³ria quando ele
sai de escopo, vocÃª nÃ£o tem que escrever e debugar cÃ³digo extra para ter esse
controle.</p>
<p>O ownership afeta o funcionamento de vÃ¡rias outras partes do Rust, por isso
vamos falar um pouco mais sobre esses conceitos neste livro daqui para a frente.
Vamos seguir para o prÃ³ximo capÃ­tulo e ver como agrupar dados em uma <code>struct</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch05-00-structs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch04-02-references-and-borrowing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch05-00-structs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
