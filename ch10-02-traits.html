<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado - A linguagem de programaÃ§Ã£o Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">ğŸ‡§ğŸ‡· A linguagem de programaÃ§Ã£o Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">ğŸ‡§ğŸ‡· PrefÃ¡cio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· ComeÃ§ando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Usando Structs para Estruturar Dados Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> ğŸ‡§ğŸ‡· Definindo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> ğŸ‡§ğŸ‡· Um Exemplo de um Programa que usa Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> ğŸ‡§ğŸ‡· Sintaxe do MÃ©todo</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> ğŸ‡§ğŸ‡· ColeÃ§Ãµes comuns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html" class="active"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸ‡§ğŸ‡· Um projeto de E/S</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸ‡§ğŸ‡· Aceitando Argumentos em Linha de Comando</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸ‡§ğŸ‡· Lendo um Arquivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸ‡§ğŸ‡· RefatoraÃ§Ã£o para Melhorar a Modularidade e o Tratamento de Erros</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸ‡§ğŸ‡· Desenvolvendo a Biblioteca de Funcionalidades</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸ‡§ğŸ‡· Trabalhando com VariÃ¡veis de Ambiente</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸ‡§ğŸ‡· Escrevendo Mensagens de Erro para Erro PadrÃ£o em Vez de SaÃ­da PadrÃ£o</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li class="chapter-item expanded "><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li class="chapter-item expanded "><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li class="chapter-item expanded "><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.6.</strong> ğŸ‡§ğŸ‡· G - Como Ã© feito o Rust e o &quot;Rust Nightly&quot;</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A linguagem de programaÃ§Ã£o Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#traits-definindo-comportamento-compartilhado" id="traits-definindo-comportamento-compartilhado">Traits: Definindo Comportamento Compartilhado</a></h2>
<p>Traits nos permitem usar outro tipo de abstraÃ§Ã£o: eles nos permitem abstrair 
sobre o comportamento que tipos tÃªm em comum. Um <em>trait</em> diz ao compilador de
Rust sobre uma funcionalidade que um tipo particular possui e pode compartilhar
com outros tipos. Em situaÃ§Ãµes onde nÃ³s usamos parÃ¢metros de tipos genÃ©ricos,
nÃ³s podemos usar <em>limites de trait</em> para especificar, em tempo de compilaÃ§Ã£o,
que o tipo genÃ©rico pode ser qualquer tipo que implementa um trait e por
conseguinte tem o comportamento que queremos usar nessa situaÃ§Ã£o.</p>
<blockquote>
<p>Nota: <em>Traits</em> sÃ£o similares a um recurso frequentemente chamado de 
'interface' em outras linguagens, com algumas diferenÃ§as.</p>
</blockquote>
<h3><a class="header" href="#definindo-um-trait" id="definindo-um-trait">Definindo um Trait</a></h3>
<p>O comportamento de um tipo consiste nos mÃ©todos que podemos chamar para aquele
tipo. Tipos diferentes dividem o mesmo comportamento se podemos chamar os 
mesmos mÃ©todos em todos esses tipos. DefiniÃ§Ãµes de traits sÃ£o um modo de 
agrupar mÃ©todos de assinaturas juntos a fim de definir um conjunto de 
comportamentos para atingir algum propÃ³sito.</p>
<p>Por exemplo, digamos que temos mÃºltiplos structs que contÃ©m vÃ¡rios tipos e
quantidades de texto: um struct <code>ArtigoDeNoticias</code>que contÃ©m uma notÃ­cia 
preenchida em um lugar do mundo, e um <code>Tweet</code> que pode ter no mÃ¡ximo 140
caracteres em seu conteÃºdo alÃ©m dos metadados como se ele foi um retweet ou uma
resposta a outro tweet.</p>
<p>NÃ³s queremos fazer uma biblioteca agregadora de mÃ­dia que pode mostrar resumos
de dados que podem estar guardados em uma instÃ¢ncia de <code>ArtigoDeNoticia</code> ou 
<code>Tweet</code>. O comportamento que precisamos cada struct possua Ã© que seja capaz de
ser resumido, e que nÃ³s possamos pedir pelo resumo chamando um mÃ©todo <code>resumo</code>
em uma instÃ¢ncia. A Listagem 10-12 mostra a definiÃ§Ã£o de um trait <code>Resumir</code> que
expressa esse conceito:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Resumir {
    fn resumo(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listagem 10-12: DefiniÃ§Ã£o de um trait <code>Resumir</code> que 
consiste no comportamento fornecido pelo mÃ©todo <code>resumo</code></span></p>
<p>NÃ³s declaramos um trait com a palavra-chave <code>trait</code>, e entÃ£o o nome do trait,
nesse caso <code>Resumir</code>. Dentro de chaves declaramos a assinatura do mÃ©todo que
descreve o comportamento que tipos que implementam esse trait precisarÃ£o ter,
nesse caso <code>fn resumo(&amp;self) -&gt; String;</code>. Depois da assinatura do mÃ©todo ao
invÃ©s de fornecer uma implementaÃ§Ã£o dentro de chaves, nÃ³s colocamos um ponto e
vÃ­rgula. Cada tipo que implementa esse trait precisa entÃ£o fornecer seu prÃ³prio
comportamento customizado para o corpo do mÃ©todo, mas o compilador vai reforÃ§ar
que qualquer qualquer tipo que tenha o trait <code>Resumir</code> terÃ¡ o mÃ©todo <code>resumo</code>
definido para ele com esse exata assinatura.</p>
<p>Um trait pode ter vÃ¡rios mÃ©todos no seu corpo, com os mÃ©todos das assinaturas
listados um por linha e cada linha terminando com um ponto e vÃ­rgula.</p>
<h3><a class="header" href="#implementando-um-trait-em-um-tipo" id="implementando-um-trait-em-um-tipo">Implementando um Trait em um Tipo</a></h3>
<p>Agora que deifnimos o trait <code>Resumir</code>, podemos implementa-lo nos tipos do nosso
agregador de mÃ­dias que queremos que tenham esse comportamento. A Listagem 
10-13 mostra uma implementaÃ§Ã£o do trait <code>Resumir</code> no struct <code>ArtigoNotÃ­cia</code> que
possui o tÃ­tulo, o autor e a localizaÃ§Ã£o para criar e retornar o valor de 
<code>resumo</code>. Para o struct <code>Tweet</code>, nÃ³s escolhemos definir <code>resumo</code> como o nome de
usuÃ¡rio seguido por todo o texto do tweet, assumindo que o conteÃºdo do tweet jÃ¡
estÃ¡ limitado a 140 caracteres.</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Resumir {
</span><span class="boring">    fn resumo(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct ArtigoDeNoticia {
    pub titulo: String,
    pub local: String,
    pub autor: String,
    pub conteudo: String,
}

impl Resumir for ArtigoDeNoticia {
    fn resumo(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.titulo, self.autor, self.local)
    }
}

pub struct Tweet {
    pub nomeusuario: String,
    pub conteudo: String,
    pub resposta: bool,
    pub retweet: bool,
}

impl Resumir for Tweet {
    fn resumo(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.nomeusuario, self.conteudo)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listagem 10-13: Implementando o trait <code>Resumir</code> nos tipos 
<code>ArtigoDeNoticia</code> e <code>Tweet</code></span></p>
<p>Implementar um trait em um tipo Ã© similar a implementar mÃ©todos que nÃ£o estÃ£o
relacionados com um trait. A diferenÃ§a estÃ¡ depois de <code>impl</code>, nÃ³s colocamos o
nome do trait que queremos implementar, entÃ£o dizemos <code>for</code> e o nome do tipo 
que queremos implementar. Dentro do bloco <code>impl</code>, nÃ³s colocamos as assinaturas
dos mÃ©todos que a definiÃ§Ã£o do trait definiu, mas ao invÃ©s de colocar um ponto
e vÃ­rgula depois de cada assinatura, nÃ³s colocamos chaves e preenchemos o corpo
do mÃ©todo com o comportamento especÃ­fico que queremos que os mÃ©todos dos traits
tenham para um tipo particular.</p>
<p>Uma vez que implementamos o trait, nÃ³s podemos chamar os mÃ©todos nas instÃ¢ncias
de <code>ArtigoDeNoticia</code> e <code>Tweet</code> da mesma maneira que nÃ³s chamamos mÃ©todos que nÃ£o
sÃ£o parte de um trait:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeUsuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como vocÃªs provavelmente jÃ¡ sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.summary());
</code></pre>
<p>Isso irÃ¡ imprimir <code>1 novo tweet: claro, como vocÃªs provavelmente jÃ¡ sabem, pessoas</code></p>
<p>Note que porque nÃ³s definimos o trait <code>Resumir</code> e os tipos <code>ArtigoDeNoticia</code> e
<code>Tweet</code> todos na mesma <code>lib.rs</code> na listagem 10-13, eles estÃ£o todos no mesmo 
escopo. Se essa <code>lib.rs</code> Ã© para um crate nÃ³s chamamos <code>agregador</code>, e se outra
pessoa quiser usar a funcionalidade do nosso crate e implementar o trait 
<code>Resumir</code> na sua struct <code>PrevisaoTempo</code>, o cÃ³digo deles precisaria importar o
trait <code>Resumir</code> no escopo deles primeiro antes deles poderem implementÃ¡-lo, 
como na Listagem 10-14:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate aggregator;

use aggregator::Resumir;

struct PrevisaoTempo {
    alta_temp: f64,
    baixa_temp: f64,
    chance_de_chuva: f64,
}

impl Resumir for PrevisaoTempo {
    fn resumo(&amp;self) -&gt; String {
        format!(&quot;A alta serÃ¡ de {}, e a baixa de {}. A chance de precipitaÃ§Ã£o Ã©
        {}%.&quot;, self.alta_temp, self.baixa_temp, self.chance_de_chuva)
    }
}
</code></pre>
<p><span class="caption">Listagem 10-14: Trazendo o trait <code>Resumir</code> do nosso crate 
<code>aggregator</code> para o escopo de outro crate</span></p>
<p>Esse cÃ³digo tambÃ©m assume que <code>Resumir</code> Ã© um trait pÃºblico, o que Ã© verdade 
porque colocamos a palavra-chave <code>pub</code> antes de <code>trait</code> na Listagem 10-12.</p>
<p>Uma restriÃ§Ã£o para se prestar atenÃ§Ã£o na implementaÃ§Ã£o de traits: nÃ³s podemos
implementar um trait em um tipo desde que o trait ou o tipo forem locais para o
nosso crate. Em outras palavras, nÃ³s nÃ£o estamos autorizados a implementar 
traits externos em tipos externos. NÃ³s nÃ£o podemos implementar o trait 
<code>Display</code> em <code>Vec</code>, por exemplo, jÃ¡ que ambos <code>Display</code> e <code>Vec</code> sÃ£o definidos na
biblioteca padrÃ£o. NÃ³s temos a permissÃ£o de implementar traits da biblioteca
padrÃ£o como <code>Display</code> em um tipo personalizado como <code>Tweet</code> como parte da
funcionalidade do nosso crate <code>aggregator</code>, jÃ¡ que nÃ³s jÃ¡ havÃ­amos definido
<code>Resumir</code> lÃ¡. Essa restriÃ§Ã£o Ã© parte do que Ã© chamado de a <em>regra do á¹rfÃ£o</em>,
qual vocÃª pode procurar se estiver interessado nesse tipo de teoria. De forma
curta, Ã© chamada de a regra do Ã³rfÃ£o porque o tipo pai nÃ£o estÃ¡ presente. Sem
essa regra, dois crates poderiam implementar o mesmo trait para o mesmo tipo,
e as duas implementaÃ§Ãµes entrariam em conflito: o Rust nÃ£o saberia qual
implementaÃ§Ã£o usar. Porque o Rust impÃµe a regra do Ã³rfÃ£o, os cÃ³digos de outras 
pessoas nÃ£o podem quebrar seu cÃ³digo e vice e versa.</p>
<h3><a class="header" href="#implementaÃ§Ãµes-padrÃ£o" id="implementaÃ§Ãµes-padrÃ£o">ImplementaÃ§Ãµes PadrÃ£o</a></h3>
<p>As vezes Ã© Ãºtil ter um comportamento padrÃ£o pra alguns ou todos os mÃ©todos em
um trait, ao invÃ©s de fazer toda implementaÃ§Ã£o em todo tipo e definir um 
comportamento personalizado. Quando implementamos o trait em um tipo 
particular, nÃ³s podemos escolher manter ou sobrescrever o comportamento padrÃ£o
de cada mÃ©todo.</p>
<p>A Listagem 10-15 mostra como poderÃ­amos ter escolhido especificar uma string 
padrÃ£o para o mÃ©todo <code>resumo</code> do trait <code>Resumir</code> ao invÃ©s de escolher de apenas
definir a assinatura do mÃ©todo como fizemos na Listagem 10-12:</p>
<p><span class="filename">Nome do arquivo: lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Resumir {
    fn resumo(&amp;self) -&gt; String {
        String::from(&quot;(Leia mais...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listagem 10-15: DefiniÃ§Ã£o de um trait <code>Resumir</code> com a 
implementaÃ§Ã£o padrÃ£o do mÃ©todo <code>resumo</code></span></p>
<p>Se nÃ³s quisÃ©ssemos usar a implementaÃ§Ã£o padrÃ£o para resumir as instÃ¢ncias de
<code>ArtigoDeNoticia</code> ao invÃ©s de definir uma implementaÃ§Ã£o personalizada como 
fizemos na Listagem 10-13, nÃ³s especificarÃ­amos um bloco <code>impl</code> vazio:</p>
<pre><code class="language-rust ignore">impl Resumir for ArtigoDeNoticia {}
</code></pre>
<p>Mesmo que nÃ£o estejamos mais escolhendo definir o mÃ©todo <code>resumo</code> diretamente 
em <code>ArtigoDeNoticia</code>, jÃ¡ que o mÃ©todo <code>resumo</code> tem uma implementaÃ§Ã£o padrÃ£o e 
nÃ³s especificamos que <code>ArtigoDeNoticia</code> implementa o trait <code>Resumir</code>, nÃ³s ainda
podemos chamar o mÃ©todo <code>resumo</code> em uma instÃ¢ncia de <code>ArtigoDeNoticia</code>:</p>
<pre><code class="language-rust ignore">let artigo = ArtigoDeNoticia {
    titulo: String::from(&quot;Os Penguins ganham a copa do campeonato Stanley&quot;),
    lugar: String::from(&quot;Pittsburgh, PA, USA&quot;),
    autor: String::from(&quot;Iceburgh&quot;),
    conteudo: String::from(&quot;Os Penguins de Pittsburgh sÃ£o novamente o melhor
    time de hockey da NHL.&quot;),
};

println!(&quot;Novo artigo disponÃ­vel! {}&quot;, artigo.summary());
</code></pre>
<p>Esse cÃ³digo imprime <code>Novo artigo disponÃ­vel! (Leia mais...)</code></p>
<p>Mudando o trait <code>Resumir</code> para ter uma implementaÃ§Ã£o padrÃ£o para <code>resumo</code> nÃ£o
requer que nÃ³s mudemos nada na implementaÃ§Ã£o de <code>Resumir</code> em <code>Tweet</code> na 
Listagem 10-13 ou em <code>PrevisaoTempo</code> na Listagem 10-14: a sintaxe para sobrepor
uma implementaÃ§Ã£o padrÃ£o Ã© exatamente a mesma de uma sintaxe para implementar
um mÃ©todo de trait que nÃ£o tem uma implementaÃ§Ã£o padrÃ£o.</p>
<p>ImplementaÃ§Ãµes padrÃµes sÃ£o autorizadas a chamar outros mÃ©todos no mesmo trait,
mesmo se os outros mÃ©todos nÃ£o tiverem uma implementaÃ§Ã£o padrÃ£o. Desse modo, um
trait pode prover muitas funcionalidades Ãºteis e apenas requerir implementaÃ§Ãµes
para especificar uma pequena parte dele. NÃ³s poderÃ­amos escolher que o trait
<code>Resumir</code> tambÃ©m tivesse o mÃ©todo <code>resumo_autor</code> qual a implementaÃ§Ã£o Ã© 
necessÃ¡ria, entÃ£o um mÃ©todo <code>resumo</code> que tem a implementaÃ§Ã£o padrÃ£o que chama
pelo mÃ©todo <code>resumo_autor</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Resumir {
    fn resumo_autor(&amp;self) -&gt; String;

    fn resumo(&amp;self) -&gt; String {
        format!(&quot;(Leia mais de {}...)&quot;, self.resumo_autor())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para usar essa versÃ£o de <code>Resumir</code>, nÃ³s sÃ³ precisamos definir <code>resumo_autor</code>
quando nÃ³s implementamos o trait em um tipo:</p>
<pre><code class="language-rust ignore">impl Resumir for Tweet {
    fn autor_resumo(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.nomeusuario)
    }
}
</code></pre>
<p>Uma vez que definimos <code>resumo_autor</code>, nÃ³s podemos chamar <code>resumo</code> em instÃ¢ncias
do struct <code>Tweet</code>, e a implementaÃ§Ã£o padrÃ£o de <code>resumo</code> chamarÃ¡ a definiÃ§Ã£o de
<code>resumo_autor</code> que fornecemos.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    nomeusuario: String::from(&quot;horse_ebooks&quot;),
    conteudo: String::from(&quot;claro, como vocÃªs provavelmente jÃ¡ sabem, 
    pessoas&quot;),
    resposta: false,
    retweet: false,
};

println!(&quot;1 novo tweet: {}&quot;, tweet.resumo());
</code></pre>
<p>Isso irÃ¡ imprimir <code>1 novo tweet: (Leia mais de @horse_ebooks...)</code>.</p>
<p>Note que nÃ£o Ã© possÃ­vel chamar a implementaÃ§Ã£o padrÃ£o de uma implementaÃ§Ã£o
primordial.</p>
<h3><a class="header" href="#limites-de-traits" id="limites-de-traits">Limites de traits</a></h3>
<p>Agora que definimos traits e os implementamos em tipos, podemos usar traits com
parÃ¢metros de tipos genÃ©ricos. Podemos restringir tipos genÃ©ricos para que ao
invÃ©s de serem qualquer tipo, o compilador tenha certeza que o tipo estarÃ¡ 
limitado a aqueles tipos que implementam um trait em particular e por 
consequÃªncia tenham o comportamento que precisamos que os tipos tenham. Isso Ã©
chamado de especificar os <em>limites dos traits</em> em um tipo genÃ©rico.</p>
<p>Por exemplo, na Listagem 10-13, nÃ³s implementamos o trait <code>Resumir</code> nos tipos
<code>ArtigoDeNoticia</code> e <code>Tweet</code>. NÃ³s podemos definir uma funÃ§Ã£o <code>notificar</code> que chama
o mÃ©todo <code>resumo</code> no seu parÃ¢metro <code>item</code>, que Ã© do tipo genÃ©rico <code>T</code>. Para 
ser possÃ­vel chamar <code>resumo</code> em <code>item</code> sem receber um erro, podemos usar os 
limites de traits em <code>T</code> para especificar que <code>item</code> precisa ser de um tipo que
implementa o trait <code>Resumir</code>:</p>
<pre><code class="language-rust ignore">pub fn notificar&lt;T: Resumir&gt;(item: T) {
    println!(&quot;NotÃ­cias de Ãºltima hora! {}&quot;, item.resumo());
}
</code></pre>
<p>Limites de traits vÃ£o juntos com a declaraÃ§Ã£o de um parÃ¢metro de tipo genÃ©rico,
depois de uma vÃ­rgula e entre colchetes angulares. Por causa do limite de trait
em  <code>T</code>, nÃ³s podemos chamar <code>notificar</code> e passar qualquer instÃ¢ncia de 
<code>ArtigoDeNoticia</code> ou <code>Tweet</code>. O cÃ³digo externo da Listagem 10-14 que estÃ¡ 
usando nosso crate <code>aggregator</code> pode chamar nossa funÃ§Ã£o <code>notificar</code> e passar
uma instÃ¢ncia de <code>PrevisaoTempo</code>, jÃ¡ que <code>Resumir</code> Ã© implementado para 
<code>PrevisaoTempo</code> tambÃ©m. O cÃ³digo que chama <code>notificar</code> com qualquer outro tipo,
como uma <code>String</code> ou um <code>i32</code>, nÃ£o compilarÃ¡, jÃ¡ que esses tipos nÃ£o 
implementam <code>Resumir</code>.</p>
<p>NÃ³s podemos especificar mÃºltiplos limites de traits em um tipo genÃ©rico usando
<code>+</code>. Se nÃ³s precisÃ¡ssemos ser capazes de usar mostrar formataÃ§Ã£o no tipo <code>T</code> em
uma funÃ§Ã£o assim como no mÃ©todo <code>resumo</code>, nÃ³s podemos usar os limites de trait
<code>T: Resumir + Mostrar</code>. Isso signifca que <code>T</code> pode ser qualquer tipo que 
implemente ambos <code>Resumir</code> e <code>Mostrar</code>.</p>
<p>Para funÃ§Ãµes que tÃªm mÃºltiplos parÃ¢metros de tipos genÃ©ricos, cada tipo 
genÃ©rico tem seu prÃ³prio limite de trait. Especificar muitas informaÃ§Ãµes de 
limites de trait dentro de chaves angulares entre o nome de uma funÃ§Ã£o e sua
lista de parÃ¢metros pode tornar o cÃ³digo difÃ­cil de ler, entÃ£o hÃ¡ uma sintaxe 
alternativa para especificar limites de traits que nos permite movÃª-los para
uma clÃ¡usula depois da assinatura da funÃ§Ã£o. EntÃ£o ao invÃ©s de:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T: Mostrar + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>NÃ³s podemos escrever isso com uma clÃ¡usula de <code>where</code>:</p>
<pre><code class="language-rust ignore">fn alguma_funcao&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Isso Ã© menos confuso e faz a assinatura da funÃ§Ã£o ficar mais parecida Ã  uma
funÃ§Ã£o sem ter vÃ¡rios limites de trait, nela o nome da funÃ§Ã£o, a lista de
parÃ¢metros, e o tipo de retorno estÃ£o mais prÃ³ximos.</p>
<h3><a class="header" href="#consertando-a-funÃ§Ã£o-maior-com-limites-de-traits" id="consertando-a-funÃ§Ã£o-maior-com-limites-de-traits">Consertando a FunÃ§Ã£o <code>maior</code> com Limites de Traits</a></h3>
<p>EntÃ£o qualquer hora que vocÃª queira usar um comportamento definido por um trait
em um tipo genÃ©rico, vocÃª precisa especificar aquele trait nos limites dos
parÃ¢metros dos tipos genÃ©ricos. Agora podemos consertar a definiÃ§Ã£o da funÃ§Ã£o 
<code>maior</code> que usa um parÃ¢metro de tipo genÃ©rico da Listagem 10-5! Quando deixamos
esse cÃ³digo de lado, nÃ³s recebemos esse erro:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
  |
5 |         if item &gt; maior {
  |            ^^^^
  |
note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>No corpo de <code>maior</code> nÃ³s querÃ­amos ser capazes de comparar dois valores de tipo
<code>T</code> usando o operador maior-que. Esse operador Ã© definido com o mÃ©todo padrÃ£o 
na biblioteca padrÃ£o de trait <code>std::cmp::PartialOrd</code>. EntÃ£o para que possamos
usar o operador maior-que, precisamos especificar <code>PartialOrd</code> nos limites do
trait  para <code>T</code> para que a funÃ§Ã£o <code>maior</code> funcione em partes de qualquer tipo
que possa ser comparada. NÃ£o precisamos trazer <code>PartialOrd</code> para o escopo 
porque estÃ¡ no prelÃºdio.</p>
<pre><code class="language-rust ignore">fn maior&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Se tentarmos compilar isso, receberemos diferentes erros:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy array
 --&gt; src/main.rs:4:23
  |
4 |     let mut maior = list[0];
  |         -----------   ^^^^^^^ cannot move out of here
  |         |
  |         hint: to prevent move, use `ref maior` or `ref mut maior`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:6:9
  |
6 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>A chave para esse erro Ã© <code>cannot move out of type [T], a non-copy array</code>. Com
nossas versÃµes nÃ£o genÃ©ricas da funÃ§Ã£o <code>maior</code>, nÃ³s estÃ¡vamos apenas tentando
encontrar o maior <code>i32</code> ou <code>char</code>. Como discutimos no CapÃ­tulo 4, tipos como o
<code>i32</code> e <code>char</code> que tÃªm um tamanho conhecido podem ser armazenados na pilha,
entÃ£o eles implementam o trait <code>Copia</code>. Quando mudamos a funÃ§Ã£o <code>maior</code> para 
ser genÃ©rica, agora Ã© possÃ­vel que o parÃ¢metro <code>list</code> poderia ter tipos nele
que nÃ£o implementam o trait <code>Copia</code>, o que significa que nÃ£o serÃ­amos capazes 
de mover o valor para fora de <code>list[0]</code> para a variÃ¡vel <code>maior</code>.</p>
<p>Se quisermos ser capazes de chamar esse cÃ³digo com tipos que sÃ£o <code>Copia</code>, nÃ³s
podemos adicionar <code>Copia</code> para os limites de trait de <code>T</code>! A Listagem 10-16 
mostra o cÃ³digo completo de uma funÃ§Ã£o <code>maior</code> genÃ©rica que compilarÃ¡ desde que
os tipos dos valores nessa parte que passamos para <code>maior</code> implementem ambos os
traits <code>PartialOrd</code> e <code>Copia</code>, como <code>i32</code> e <code>char</code>:</p>
<p><span class="filename">Nome do arquivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn maior&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut maior = list[0];

    for &amp;item in list.iter() {
        if item &gt; maior {
            maior = item;
        }
    }

    maior
}

fn main() {
    let lista_numero = vec![34, 50, 25, 100, 65];

    let result = maior(&amp;lista_numero);
    println!(&quot;O maior nÃºmero Ã© {}&quot;, result);

    let lista_char = vec!['y', 'm', 'a', 'q'];

    let result = maior(&amp;lista_char);
    println!(&quot;O maior char Ã© {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listagem 10-16: Uma definiÃ§Ã£o funcional da funÃ§Ã£o <code>maior</code>
que funciona em qualquer tipo genÃ©rico que implementa os traits <code>PartialOrd</code> e
<code>Copia</code></span></p>
<p>Se nÃ£o quisermos restringir nossa funÃ§Ã£o <code>maior</code> para apenas tipos que 
implementam o trait <code>Copia</code>, podemos especificar que <code>T</code> tem o limite de trait
<code>Clone</code> ao invÃ©s de <code>Copia</code> e clonar cada valor na parte quando quisermos que a
funÃ§Ã£o <code>maior</code> tenha domÃ­nio. Usando a funÃ§Ã£o <code>clone</code> significa que 
potencialmente estamos fazendo mais alocaÃ§Ãµes no heap, porÃ©m, e alocaÃ§Ãµes no 
heap podem ser vagarosas se estivermos trabalhando com grande quantidade de 
dados. Outro jeito que podemos implementar <code>maior</code> Ã© para a funÃ§Ã£o retornar uma
referÃªncia ao valor de <code>T</code> em uma parte. Se retornarmos o tipo de retorno para
ser <code>&amp;T</code> ao invÃ©s de <code>T</code> e mudar o corpo da funÃ§Ã£o para retornar uma 
referÃªncia, nÃ£o precisarÃ­amos usar os limites de traits <code>Clone</code> ou <code>Copia</code> e
nÃ³s nÃ£o estarÃ­amos fazendo nenhuma alocaÃ§Ã£o de heap.
Tente implementar essas soluÃ§Ãµes alternativas vocÃª mesmo! </p>
<h3><a class="header" href="#usando-limites-de-trait-para-implementar-mÃ©todos-condicionalmente" id="usando-limites-de-trait-para-implementar-mÃ©todos-condicionalmente">Usando Limites de Trait para Implementar MÃ©todos Condicionalmente</a></h3>
<p>Usando um limite de trait com um bloco <code>impl</code> que usa parÃ¢metros de tipos 
genÃ©ricos podemos implementar mÃ©todos condicionalmente apenas para tipos que
implementam os traits especÃ­ficos. Por exemplo, o tipo <code>Par&lt;T&gt;</code> na listagem 
10-17 sempre implementa o mÃ©todo <code>novo</code>, mas <code>Par&lt;T&gt;</code> implementa apenas o
<code>cmp_display</code> se seu tipo interno <code>T</code> implementa o trait <code>PartialOrd</code> que 
permite a comparaÃ§Ã£o e do trait <code>Display</code> que permite a impressÃ£o:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Par&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Par&lt;T&gt; {
    fn novo(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Par&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;O maior membro Ã© x = {}&quot;, self.x);
        } else {
            println!(&quot;O maior membro Ã© y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listagem 10-17: Implementa mÃ©todos condicionalmente em um
tipo genÃ©rico dependendo dos limites de trait</span></p>
<p>Podemos tambÃ©m condicionalmente implementar um trait para qualquer tipo que
implementa um trait. ImplementaÃ§Ãµes de trait de qualquer tipo que satisfazem os
limites de trait sÃ£o chamadas de <em>implementaÃ§Ãµes cobertores</em>, e sÃ£o 
extesivamente utilizadas na biblioteca padrÃ£o de Rust. Por exemplo, a 
biblioteca padrÃ£o implementa o trait <code>Display</code>. Esse bloco <code>impl</code> se parece com
este cÃ³digo:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Porque a biblioteca padrÃ£o tem essa implementaÃ§Ã£o cobertor, podemos chamar
o mÃ©todo <code>to_string</code> definido pelo tipo <code>ToString</code> em qualquer tipo que 
implemente o trait <code>Display</code>. Por exemplo, nÃ³s podemos transformar inteiros em
seus correspondentes valores de <code>String</code> do seguinte modo, jÃ¡ que inteiros 
implementam <code>Display</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>ImplementaÃ§Ãµes cobertor aparecem na documentaÃ§Ã£o para traits na seÃ§Ã£o 
&quot;Implementadores&quot;.</p>
<p>Traits e limites de traits nos deixam escrever cÃ³digo que usam parÃ¢metros de
tipos genÃ©ricos para reduzir a duplicaÃ§Ã£o, mas ainda sim especificam para o
compilador exatamente qual o comportamento que nosso cÃ³digo precisa que o tipo
genÃ©rico tenha. Porque demos a informaÃ§Ã£o do limite de trait para o compilador,
ele pode checar que todos os tipos concretos usados no nosso cÃ³digo 
proporcionam o comportamento correto. Em linguagens dinamicamente tipadas, se
nÃ³s tentÃ¡ssemos chamar um mÃ©todo em um tipo que nÃ£o implementamos, nÃ³s 
receberÃ­amos um erro em tempo de execuÃ§Ã£o. O Rust move esses erros para o temp
de compilaÃ§Ã£o para que possamos ser forÃ§ados a resolver os problemas antes que 
nosso cÃ³digo seja capaz de rodar. AlÃ©m disso, nÃ³s nÃ£o temos que escrever cÃ³digo
que checa o comportamento em tempo de execuÃ§Ã£o jÃ¡ que jÃ¡ checamos em tempo de
compilaÃ§Ã£o, o que melhora o desempenho comparado com outras linguagens sem ter
que abrir mÃ£o da flexibilidade de tipos genÃ©ricos. </p>
<p>HÃ¡ outro tipo de tipos genÃ©ricos que estamos usando sem nem ao menos perceber
chamados <em>lifetimes</em>. Em vez de nos ajudar a garantir que um tipo tenha o
comportamento que precisamos, lifetimes nos ajudam a garantir que as 
referÃªncias sÃ£o vÃ¡lidas tanto quanto precisam ser. Vamos aprender como 
lifetimes fazem isso.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch10-01-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch10-03-lifetime-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch10-01-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch10-03-lifetime-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
