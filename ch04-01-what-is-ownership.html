<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· O Que Ã‰ Ownership? - A linguagem de programaÃ§Ã£o Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">ğŸ‡§ğŸ‡· A linguagem de programaÃ§Ã£o Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">ğŸ‡§ğŸ‡· PrefÃ¡cio</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· ComeÃ§ando</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html" class="active"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Usando Structs para Estruturar Dados Relacionados</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> ğŸ‡§ğŸ‡· Definindo e Instanciando Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> ğŸ‡§ğŸ‡· Um Exemplo de um Programa que usa Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> ğŸ‡§ğŸ‡· Sintaxe do MÃ©todo</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li class="chapter-item expanded "><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li class="chapter-item expanded "><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> ğŸ‡§ğŸ‡· ColeÃ§Ãµes comuns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> ğŸ‡§ğŸ‡· Um projeto de E/S</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> ğŸ‡§ğŸ‡· Aceitando Argumentos em Linha de Comando</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ğŸ‡§ğŸ‡· Lendo um Arquivo</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> ğŸ‡§ğŸ‡· RefatoraÃ§Ã£o para Melhorar a Modularidade e o Tratamento de Erros</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> ğŸ‡§ğŸ‡· Desenvolvendo a Biblioteca de Funcionalidades</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> ğŸ‡§ğŸ‡· Trabalhando com VariÃ¡veis de Ambiente</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> ğŸ‡§ğŸ‡· Escrevendo Mensagens de Erro para Erro PadrÃ£o em Vez de SaÃ­da PadrÃ£o</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li class="chapter-item expanded "><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li class="chapter-item expanded "><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li class="chapter-item expanded "><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.6.</strong> ğŸ‡§ğŸ‡· G - Como Ã© feito o Rust e o &quot;Rust Nightly&quot;</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A linguagem de programaÃ§Ã£o Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#o-que-Ã‰-ownership" id="o-que-Ã‰-ownership">O Que Ã‰ Ownership?</a></h2>
<p>A caracterÃ­stica central do Rust Ã© <em>ownership</em>. Embora seja bem direta de
explicar, ela tem implicaÃ§Ãµes profundas em todo o resto da linguagem.</p>
<p>Todos os programas tÃªm que decidir de que forma vÃ£o usar a memÃ³ria do computador
durante a execuÃ§Ã£o. Algumas linguagens possuem <em>garbage collection</em> (coleta de
lixo), que constantemente busca segmentos de memÃ³ria que jÃ¡ nÃ£o sÃ£o mais
utilizados enquanto o programa executa; em outras linguagens, o programador deve
alocar e liberar memÃ³ria de forma explÃ­cita. Rust usa uma terceira abordagem: a
memÃ³ria Ã© gerenciada atravÃ©s de um sistema de posse, que tem um conjunto de
regras verificadas em tempo de compilaÃ§Ã£o. Nenhuma caracterÃ­stica relacionada ao
ownership implica qualquer custo em tempo de execuÃ§Ã£o.</p>
<p>Como ownership Ã© um conceito novo para muitos programadores, leva um pouco de
tempo para se acostumar. A boa notÃ­cia Ã© que quanto mais experiente vocÃª se
torna em Rust e nas regras do sistema de posse, mais vocÃª serÃ¡ capaz de
escrever, naturalmente, cÃ³digo seguro e eficiente. Fique aÃ­!</p>
<p>Quando vocÃª entender ownership, vocÃª terÃ¡ uma fundaÃ§Ã£o sÃ³lida para entender as
caracterÃ­sticas que fazem o Rust ser Ãºnico. Neste capÃ­tulo, vocÃª vai aprender
ownership trabalhando em alguns exemplos com foco em uma estrutura de dados
muito comum: <em>strings</em>.</p>
<!-- PROD: START BOX -->
<blockquote>
<h3><a class="header" href="#a-pilha-e-a-heap" id="a-pilha-e-a-heap">A Pilha e a <em>Heap</em></a></h3>
<p>Em muitas linguagens de programaÃ§Ã£o, nÃ£o temos que pensar muito sobre a pilha
e sobre a <em>heap</em>. Mas em uma linguagem de programaÃ§Ã£o de sistemas, como Rust,
o fato de um valor estar na pilha ou na heap tem impacto na forma como a
linguagem se comporta e no porquÃª de termos que tomar certas decisÃµes. Vamos
descrever partes do ownership em relaÃ§Ã£o Ã  pilha e Ã  heap mais para a frente
neste capÃ­tulo, entÃ£o aqui vai uma explicaÃ§Ã£o preparatÃ³ria.</p>
<p>Tanto a pilha como a heap sÃ£o partes da memÃ³ria que estÃ£o disponÃ­veis ao seu
cÃ³digo para uso em tempo de execuÃ§Ã£o, mas elas sÃ£o estruturadas de formas
diferentes. A pilha armazena valores na ordem em que eles chegam, e os remove
na ordem inversa. Isto Ã© chamado de <em>last in, first out</em> (Ãºltimo a chegar,
primeiro a sair). Imagine uma pilha de pratos: quando vocÃª coloca mais pratos,
vocÃª os pÃµe em cima da pilha, e quando vocÃª precisa de um prato, vocÃª pega o
que estÃ¡ no topo. Adicionar ou remover pratos do meio ou do fundo nÃ£o funciona
tÃ£o bem! Dizemos fazer um <em>push</em> na pilha quando nos refererimos a inserir
dados, e fazer um <em>pop</em> da pilha quando nos referimos a remover dados.</p>
<p>A pilha Ã© rÃ¡pida por conta da forma como ela acessa os dados: ela nunca tem
que procurar um lugar para colocar novos dados, ou um lugar de onde obter
dados, este lugar Ã© sempre o topo da pilha. Outra propriedade que faz a pilha
ser rÃ¡pida Ã© que todos os dados contidos nela devem ocupar um tamanho fixo e
conhecido.</p>
<p>Para dados com um tamanho desconhecido em tempo de compilaÃ§Ã£o, ou com um
tamanho que pode mudar, podemos usar a heap em vez da pilha. A heap Ã© menos
organizada: quando colocamos dados na heap, nÃ³s pedimos um certo espaÃ§o de
memÃ³ria. O sistema operacional encontra um espaÃ§o vazio em algum lugar na heap
que seja grande o suficiente, marca este espaÃ§o como em uso, e nos retorna um
<em>ponteiro</em>, que Ã© o endereÃ§o deste local. Este processo Ã© chamado de
<em>alocar na heap</em>, e Ã s vezes se abrevia esta frase como apenas &quot;alocaÃ§Ã£o&quot;.
Colocar valores na pilha nÃ£o Ã© considerado uma alocaÃ§Ã£o. Como o ponteiro tem
um tamanho fixo e conhecido, podemos armazenÃ¡-lo na pilha, mas quando queremos
os dados, de fato, temos que seguir o ponteiro. </p>
<p>Imagine que vocÃª estÃ¡ sentado em um restaurante. Quando vocÃª entra, vocÃª diz
o nÃºmero de pessoas que estÃ£o com vocÃª, o atendente encontra uma mesa vazia
que acomode todos e os leva para lÃ¡. Se alguÃ©m do seu grupo chegar mais tarde,
poderÃ¡ perguntar onde vocÃªs estÃ£o para encontrÃ¡-los.</p>
<p>Acessar dados na heap Ã© mais lento do que acessar dados na pilha, porque vocÃª
precisa seguir um ponteiro para chegar lÃ¡. Processadores de hoje em dia sÃ£o
mais rÃ¡pidos se nÃ£o precisarem pular tanto de um lugar para outro na memÃ³ria.
Continuando com a analogia, considere um garÃ§om no restaurante anotando os
pedidos de vÃ¡rias mesas. Ã‰ mais eficiente anotar todos os pedidos de uma Ãºnica
mesa antes de passar para a mesa seguinte. Anotar um pedido da mesa A, depois
um da mesa B, depois outro da mesa A, e outro da mesa B novamente seria um
processo bem mais lento. Da mesma forma, um processador pode cumprir melhor
sua tarefa se trabalhar em dados que estÃ£o prÃ³ximos uns dos outros (assim como
estÃ£o na pilha) em vez de dados afastados entre si (como podem estar na heap).
Alocar um espaÃ§o grande na heap tambÃ©m pode levar tempo.</p>
<p>Quando nosso cÃ³digo chama uma funÃ§Ã£o, os valores passados para ela (incluindo
possÃ­veis ponteiros para dados na heap) e as variÃ¡veis locais da funÃ§Ã£o sÃ£o
colocados na pilha. Quando a funÃ§Ã£o termina, esses valores sÃ£o removidos dela.</p>
<p>Rastrear quais partes do cÃ³digo estÃ£o usando quais dados na heap, minimizar a
quantidade de dados duplicados na heap e limpar segmentos inutilizados da heap
para que nÃ£o fiquemos sem espaÃ§o sÃ£o todos problemas tratados pelo ownership.
Uma vez que vocÃª entende ownership, vocÃª nÃ£o vai mais precisar pensar tanto
sobre a pilha e a heap, mas saber que ownership existe para gerenciar os dados
na heap pode ajudar a explicar como e por que ele funciona.</p>
</blockquote>
<!-- PROD: END BOX -->
<h3><a class="header" href="#regras-de-ownership" id="regras-de-ownership">Regras de Ownership</a></h3>
<p>Primeiro, vamos dar uma olhada nas regras de ownership. Mantenha em mente essas
regras quando trabalharmos com os exemplos em seguida:</p>
<blockquote>
<ol>
<li>Cada valor em Rust possui uma variÃ¡vel que Ã© dita seu <em>owner</em> (sua dona).</li>
<li>Pode apenas haver um owner por vez.</li>
<li>Quando o owner sai fora de escopo, o valor serÃ¡ destruÃ­do.</li>
</ol>
</blockquote>
<h3><a class="header" href="#escopo-de-variÃ¡veis" id="escopo-de-variÃ¡veis">Escopo de VariÃ¡veis</a></h3>
<p>JÃ¡ analisamos um exemplo de programa em Rust no CapÃ­tulo 2. Agora que jÃ¡
passamos da sintaxe bÃ¡sica, nÃ£o vamos incluir o cÃ³digo <code>fn main() {</code> nos
prÃ³ximos exemplos, entÃ£o se vocÃª estiver acompanhando, terÃ¡ que colocÃ¡-los
manualmente dentro de uma funÃ§Ã£o <code>main</code>. Como resultado, nossos exemplos serÃ£o
um pouco mais concisos, mantendo o foco nos detalhes que realmente interessam.</p>
<p>Como um primeiro exemplo de ownership, vamos olhar para o <em>escopo</em> de algumas
variÃ¡veis. Um escopo Ã© a Ã¡rea dentro de um programa para a qual um item Ã©
vÃ¡lido. Digamos que nÃ³s temos uma variÃ¡vel como esta:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;olÃ¡&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>A variÃ¡vel <code>s</code> se refere a uma string literal cujo valor Ã© fixo no cÃ³digo. A
variÃ¡vel Ã© vÃ¡lida do ponto em que Ã© declarada atÃ© o fim do atual <em>escopo</em>. A
Listagem 4-1 tem comentÃ¡rios indicando onde a variÃ¡vel <code>s</code> Ã© vÃ¡lida:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // s nÃ£o Ã© vÃ¡lida aqui, ainda nÃ£o estÃ¡ declarada
    let s = &quot;texto&quot;;   // s Ã© vÃ¡lida deste ponto em diante

    // faz alguma coisa com s
}                      // agora este escopo terminou, e s nÃ£o Ã© mais vÃ¡lida
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listagem 4-1: Uma variÃ¡vel e o escopo em que ela Ã©
vÃ¡lida.</span></p>
<p>Em outras palavras, existem dois pontos no tempo que sÃ£o importantes aqui:</p>
<ol>
<li>Quando <code>s</code> <em>entra no escopo</em>, ela Ã© vÃ¡lida.</li>
<li>Permanece dessa maneira atÃ© que ela <em>saia de escopo</em>.</li>
</ol>
<p>Neste ponto, a relaÃ§Ã£o entre escopos e quando variÃ¡veis sÃ£o vÃ¡lidas Ã© similar a
outras linguagens de programaÃ§Ã£o. Agora vamos construir sobre este entendimento,
apresentando o tipo <code>String</code>.</p>
<h3><a class="header" href="#o-tipo-string" id="o-tipo-string">O Tipo <code>String</code></a></h3>
<p>Para ilustrar as regras de ownership, precisamos de um tipo de dados que seja
mais complexo do que aqueles abordados no CapÃ­tulo 3. Os tipos abordados na
seÃ§Ã£o &quot;Tipos de Dados&quot; sÃ£o todos armazenados na pilha, e retirados dela quando
seu escopo termina, mas queremos ver dados que sÃ£o armazenados na heap e
explorar como o Rust faz para saber quando limpar esses dados.</p>
<p>Vamos usar <code>String</code> como exemplo aqui, e concentrar nas partes de <code>String</code> que
estÃ£o relacionadas ao ownership. Esses aspectos tambÃ©m se aplicam aos outros
tipos complexos de dados fornecidos pela biblioteca padrÃ£o e os que vocÃª mesmo
cria. Vamos discutir <code>String</code> mais a fundo no CapÃ­tulo 8. </p>
<p>JÃ¡ vimos strings literais, em que um valor de string Ã© fixado pelo cÃ³digo do
nosso programa. Strings literais sÃ£o convenientes, mas nem sempre sÃ£o adequadas
para situaÃ§Ãµes em que queremos usar texto. Um motivo Ã© que elas sÃ£o imutÃ¡veis.
Outro Ã© que nem todos os valores de string sÃ£o conhecidos enquanto escrevemos
nosso cÃ³digo: por exemplo, o que fazer se queremos obter uma entrada do usuÃ¡rio
e armazenÃ¡-la? Para essas situaÃ§Ãµes, Rust tem um segundo tipo de strings,
<code>String</code>. Este tipo Ã© alocado na heap, e como tal, Ã© capaz de armazenar uma
quantidade de texto que Ã© desconhecida em tempo de compilaÃ§Ã£o. VocÃª pode criar
uma <code>String</code> de uma string literal usando a funÃ§Ã£o <code>from</code>, da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;texto&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>O <code>::</code> Ã© um operador que nos permite indicar que o <em>namespace</em> desta funÃ§Ã£o
<code>from</code>, em particular, Ã© o tipo <code>String</code>, de forma que nÃ£o precisamos usar um
nome especÃ­fico como <code>string_from</code>. Vamos discutir esta sintaxe na seÃ§Ã£o
&quot;Sintaxe do MÃ©todo&quot; do CapÃ­tulo 5, e quando falarmos sobre <em>namespaces</em> com
mÃ³dulos no CapÃ­tulo 7.</p>
<p>Este tipo de string <em>pode</em> ser alterada:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;olÃ¡&quot;);

s.push_str(&quot;, mundo!&quot;); // push_str() adiciona um literal Ã  String

println!(&quot;{}&quot;, s); // Isso vai exibir `olÃ¡, mundo!`
<span class="boring">}
</span></code></pre></pre>
<p>Mas entÃ£o, qual Ã© a diferenÃ§a aqui? Por que <code>String</code> pode ser alterada enquanto
literais nÃ£o podem? A diferenÃ§a estÃ¡ em como esses dois tipos lidam com memÃ³ria.</p>
<h3><a class="header" href="#memÃ³ria-e-alocaÃ§Ã£o" id="memÃ³ria-e-alocaÃ§Ã£o">MemÃ³ria e AlocaÃ§Ã£o</a></h3>
<p>No caso de uma string literal, sabemos o seu conteÃºdo em tempo de compilaÃ§Ã£o,
entÃ£o o texto Ã© injetado diretamente para dentro do executÃ¡vel final, o que
faz strings literais serem rÃ¡pidas e eficientes. Mas essas propriedades provÃªm
apenas da sua imutabilidade. Infelizmente, nÃ£o podemos colocar um segmento de
memÃ³ria dentro do binÃ¡rio para cada texto cujo tamanho Ã© desconhecido em tempo
de compilaÃ§Ã£o, e cujo tamanho pode mudar ao longo da execuÃ§Ã£o do programa.</p>
<p>Com o tipo <code>String</code>, para poder acomodar um trecho mutÃ¡vel e expansÃ­vel de
texto, precisamos alocar uma quantidade de memÃ³ria na heap, que Ã© desconhecida
em tempo de compilaÃ§Ã£o, para manter o seu conteÃºdo. Isto significa que:</p>
<ol>
<li>A memÃ³ria deve ser solicitada ao sistema operacional em tempo de execuÃ§Ã£o.</li>
<li>Precisamos de uma forma de retornar esta memÃ³ria ao sistema operacional
quando tivermos finalizado nossa <code>String</code>.</li>
</ol>
<p>A primeira parte Ã© feita por nÃ³s: quando chamamos <code>String::from</code>, sua
implementaÃ§Ã£o solicita a memÃ³ria de que precisa. Isso Ã© meio que universal em
linguagens de programaÃ§Ã£o.</p>
<p>No entanto, a segunda parte Ã© diferente. Em linguagens com um <em>garbage collector
(GC)</em>, o GC rastreia e limpa a memÃ³ria que nÃ£o estÃ¡ mais sendo usada, e nÃ³s,
como programadores, nÃ£o precisamos pensar sobre isso. Sem um GC, Ã©
responsabilidade do programador identificar quando a memÃ³ria nÃ£o estÃ¡ mais sendo
usada e chamar, explicitamente, um cÃ³digo que a retorne, assim como fizemos para
solicitÃ¡-la. Fazer isso corretamente tem sido, historicamente, um problema
difÃ­cil de programaÃ§Ã£o. Se esquecermos, vamos desperdiÃ§ar memÃ³ria. Se fizermos
cedo demais, teremos uma variÃ¡vel invÃ¡lida. Se fizermos duas vezes, tambÃ©m serÃ¡
um bug. Precisamos casar exatamente um <code>allocate</code> (alocar) com exatamente um
<code>free</code> (liberar).</p>
<p>Rust segue um caminho diferente: a memÃ³ria Ã© automaticamente retornada assim que
a variÃ¡vel que a possui sai de escopo. Aqui estÃ¡ uma versÃ£o do nosso exemplo de
escopo da Listagem 4-1 usando uma <code>String</code> em vez de uma string literal:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;texto&quot;); // s Ã© vÃ¡lida deste ponto em diante

    // faz alguma coisa com s
}                                  // agora este escopo terminou, e s nÃ£o Ã©
                                   // mais vÃ¡lida
<span class="boring">}
</span></code></pre></pre>
<p>Existe um ponto natural em que podemos retornar ao sistema operacional a memÃ³ria
da qual precisa nossa <code>String</code>: quando <code>s</code> sai de escopo. Quando uma variÃ¡vel
sai de escopo, o Rust chama para nÃ³s uma funÃ§Ã£o especial. Essa funÃ§Ã£o Ã© chamada
<code>drop</code>, e Ã© aÃ­ que o autor de <code>String</code> pode colocar o cÃ³digo que retorna
a memÃ³ria. Rust chama <code>drop</code> automaticamente ao fechar chaves (<code>}</code>).</p>
<blockquote>
<p>Nota: Em C++, esta forma de desalocar recursos no fim do tempo de vida Ãºtil de
um item Ã s vezes Ã© chamado de <em>Resource Acquisition Is Initialization</em> (RAII,
do inglÃªs, AquisiÃ§Ã£o de Recurso Ã‰ InicializaÃ§Ã£o). A funÃ§Ã£o <code>drop</code> em Rust vai
lhe ser bastante familar se vocÃª jÃ¡ tiver usado padrÃµes RAII.</p>
</blockquote>
<p>Este padrÃ£o tem um profundo impacto na forma de escrever cÃ³digo em Rust. Pode
parecer simples agora, mas o comportamento do cÃ³digo pode ser inesperado em
situaÃ§Ãµes mais complicadas, quando queremos que mÃºltiplas variÃ¡veis usem os
dados que alocamos na heap. Vamos explorar algumas dessas situaÃ§Ãµes agora.</p>
<h4><a class="header" href="#formas-de-interaÃ§Ã£o-entre-variÃ¡veis-e-dados-move" id="formas-de-interaÃ§Ã£o-entre-variÃ¡veis-e-dados-move">Formas de InteraÃ§Ã£o Entre VariÃ¡veis e Dados: <em>Move</em></a></h4>
<p>MÃºltiplas variÃ¡veis podem interagir com os mesmos dados de diferentes formas em
Rust. Vamos ver um exemplo usando um nÃºmero inteiro na Listagem 4-2:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listagem 4-2: Atribuindo o valor inteiro da variÃ¡vel <code>x</code>
para <code>y</code>.</span></p>
<p>Provavelmente podemos advinhar o que isto faz com base nas nossas experiÃªncias
com outras linguagens: &quot;Associe o valor <code>5</code> a <code>x</code>; depois faÃ§a uma cÃ³pia do
valor em <code>x</code> e a associe a <code>y</code>.&quot; Agora temos duas variÃ¡veis, <code>x</code> e <code>y</code>, e ambas
sÃ£o iguais a <code>5</code>. Ã‰ isto mesmo que acontece, porque nÃºmeros inteiros sÃ£o valores
simples que possuem um tamanho fixo e conhecido, e esses dois valores <code>5</code> sÃ£o
colocados na pilha.</p>
<p>Agora vamos ver a versÃ£o usando <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;texto&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>Isso parece bem similar ao cÃ³digo anterior, entÃ£o poderÃ­amos assumir que
funcionaria da mesma forma, isto Ã©, a segunda linha faria uma cÃ³pia do valor em
<code>s1</code> e a associaria a <code>s2</code>. Mas nÃ£o Ã© exatamente isso que acontece.</p>
<p>Para explicar isso mais detalhadamente, vamos ver como a <code>String</code> funciona por
baixo dos panos na Figura 4-1. Uma <code>String</code> Ã© feita de trÃªs partes, mostradas
Ã  esquerda: um ponteiro para a memÃ³ria que guarda o conteÃºdo da string, um
tamanho, e uma capacidade. Este grupo de dados Ã© armazenado na pilha. No lado
direito estÃ¡ a memÃ³ria na heap que guarda o conteÃºdo.</p>
<img alt="String na memÃ³ria" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figura 4-1: RepresentaÃ§Ã£o na memÃ³ria de uma <code>String</code>
contendo o valor <code>&quot;texto&quot;</code> associado a <code>s1</code>.</span></p>
<p>O tamanho representa quanta memÃ³ria, em bytes, o conteÃºdo da <code>String</code> estÃ¡
usando atualmente. A capacidade Ã© a quantidade total de memÃ³ria, em bytes, que
a <code>String</code> recebeu do sistema operacional. A diferenÃ§a entre tamanho e
capacidade Ã© importante, mas nÃ£o neste contexto, entÃ£o nÃ£o hÃ¡ problema em
ignorar a capacidade por enquanto.</p>
<p>Quando atribuÃ­mos <code>s1</code> a <code>s2</code>, os dados da <code>String</code> sÃ£o copiados, o que
significa que estamos copiando o ponteiro, o tamanho e a capacidade que estÃ£o na
pilha. NÃ£o estamos copiando os dados que estÃ£o na heap, aos quais o ponteiro se
refere. Em outras palavras, a representaÃ§Ã£o dos dados na memÃ³ria ocorre como
na Figura 4-2.</p>
<img alt="s1 e s2 apontando para o mesmo valor" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figura 4-2: RepresentaÃ§Ã£o na memÃ³ria da variÃ¡vel <code>s2</code>, que
tem uma cÃ³pia do ponteiro, tamanho e capacidade de <code>s1</code>.</span></p>
<p>A representaÃ§Ã£o <em>nÃ£o</em> ocorre como na Figura 4-3, que Ã© como ficaria a memÃ³ria se
o Rust tambÃ©m copiasse os dados da heap. Se o Rust fizesse isso, a operaÃ§Ã£o
<code>s2 = s1</code> seria potencialmente bastante custosa em termos de desempenho em tempo
de execuÃ§Ã£o caso os dados na heap fossem grandes.</p>
<img alt="s1 e s2 em dois lugares" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figura 4-3: Outra possibilidade do que <code>s2 = s1</code> poderia
fazer se o Rust tambÃ©m copiasse os dados da heap.</span></p>
<p>Anteriormente, dissemos que, quando uma variÃ¡vel sai de escopo, o Rust
automaticamente chama a funÃ§Ã£o <code>drop</code> e limpa a memÃ³ria da heap para esta
variÃ¡vel. Mas a Figura 4-2 mostra que os dois ponteiros estÃ£o apontando para o
mesmo lugar. Isso Ã© um problema: quando <code>s2</code> e <code>s1</code> saem de escopo, os dois vÃ£o
tentar liberar a mesma memÃ³ria. Isso Ã© conhecido como erro de <em>double free</em>
(liberaÃ§Ã£o dupla), e Ã© um dos bugs de seguranÃ§a de memÃ³ria que mencionamos
anteriormente. Liberar memÃ³ria duas vezes pode levar Ã  corrupÃ§Ã£o da memÃ³ria,
o que pode, por sua vez, trazer potenciais vulnerabilidades de seguranÃ§a.</p>
<p>Para garantir a seguranÃ§a de memÃ³ria, hÃ¡ um outro detalhe sobre o que acontece
nesta situaÃ§Ã£o em Rust. Em vez de tentar copiar a memÃ³ria alocada, o Rust
considera que <code>s1</code> deixa de ser vÃ¡lida, e portanto, o Rust nÃ£o precisa liberar
nenhuma memÃ³ria quando <code>s1</code> sai de escopo. Veja sÃ³ o que acontece quando vocÃª
tenta usar <code>s1</code> depois que <code>s2</code> Ã© criada, nÃ£o vai funcionar:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;texto&quot;);
let s2 = s1;

println!(&quot;{}&quot;, s1);
</code></pre>
<p>VocÃª vai ter um erro como este, porque o Rust lhe impede de usar a referÃªncia
que foi invalidada:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:20
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}&quot;, s1);
  |                    ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>Se vocÃª jÃ¡ ouviu os termos &quot;cÃ³pia rasa&quot; e &quot;cÃ³pia profunda&quot; (<em>shallow copy</em> e
<em>deep copy</em>) enquanto trabalhava com outras linguagens, o conceito de copiar o
ponteiro, tamanho e capacidade sem copiar os dados provavelmente parece uma
cÃ³pia rasa. Mas como o Rust tambÃ©m invalida a primeira variÃ¡vel, em vez de
chamar isto de cÃ³pia rasa, isto Ã© conhecido como um <em>move</em>. Aqui poderÃ­amos
dizer que <code>s1</code> foi <em>movida</em> para <code>s2</code>. EntÃ£o, o que realmente acontece Ã©
mostrado na Figura 4-4.</p>
<img alt="s1 movida para s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figura 4-4: RepresentaÃ§Ã£o na memÃ³ria depois de <code>s1</code> ter
sido invalidada.</span></p>
<p>Isso resolve o nosso problema! Tendo apenas <code>s2</code> vÃ¡lida, quando ela sair de
escopo, somente ela vai liberar a memÃ³ria, e pronto.</p>
<p>Ademais, isto implica uma decisÃ£o de projeto: Rust nunca vai criar <em>deep copies</em>
dos seus dados. Logo, para qualquer cÃ³pia <em>automÃ¡tica</em> que aconteÃ§a, pode-se
assumir que ela nÃ£o serÃ¡ custosa em termos de desempenho em tempo de execuÃ§Ã£o. </p>
<h4><a class="header" href="#formas-de-interaÃ§Ã£o-entre-variÃ¡veis-e-dados-clone" id="formas-de-interaÃ§Ã£o-entre-variÃ¡veis-e-dados-clone">Formas de InteraÃ§Ã£o Entre VariÃ¡veis e Dados: Clone</a></h4>
<p>Se nÃ³s <em>queremos</em> fazer uma cÃ³pia profunda dos dados da <code>String</code> que estÃ£o na
heap, e nÃ£o apenas os dados que estÃ£o na pilha, podemos usar um mÃ©todo comum
chamado <code>clone</code>. Vamos discutir sintaxe de mÃ©todos no CapÃ­tulo 5, mas como os
mÃ©todos constituem uma caracterÃ­stica comum em vÃ¡rias linguagens de programaÃ§Ã£o,
vocÃª provavelmente jÃ¡ os viu antes.</p>
<p>Aqui estÃ¡ um exemplo de uso do mÃ©todo <code>clone</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;texto&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Isto funciona bem, e Ã© assim que vocÃª pode, explicitamente, produzir o
comportamento mostrado na Figura 4-3, onde os dados da heap <em>sÃ£o</em> copiados.</p>
<p>Quando vocÃª ver uma chamada para <code>clone</code>, vocÃª sabe que algum cÃ³digo arbitrÃ¡rio
estÃ¡ sendo executado, e que este cÃ³digo talvez seja custoso. Ã‰ um indicador
visual de que algo diferente estÃ¡ acontecendo.</p>
<h4><a class="header" href="#dados-somente-da-pilha-copy" id="dados-somente-da-pilha-copy">Dados Somente da Pilha: Copy</a></h4>
<p>HÃ¡ um outro detalhezinho de que ainda nÃ£o falamos. Este cÃ³digo usando nÃºmeros
inteiros, parte do qual foi mostrado anteriormente na Listagem 4-2, funciona e Ã©
vÃ¡lido:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Mas este cÃ³digo parece contradizer o que acabamos de aprender: nÃ£o temos uma
chamada ao mÃ©todo <code>clone</code>, mas <code>x</code> ainda Ã© vÃ¡lido e nÃ£o foi movido para <code>y</code>.</p>
<p>O motivo Ã© que tipos como nÃºmeros inteiros tÃªm um tamanho conhecido em tempo de
compilaÃ§Ã£o e sÃ£o armazenados inteiramente na pilha, e por isso, cÃ³pias desses
valores sÃ£o rÃ¡pidas de se fazer. Isso significa que nÃ£o hÃ¡ razÃ£o para impedir
<code>x</code> de ser vÃ¡lido apÃ³s criarmos a variÃ¡vel <code>y</code>. Em outras palavras, nÃ£o hÃ¡
diferenÃ§a entre cÃ³pia rasa e profunda aqui, entÃ£o chamar o mÃ©todo <code>clone</code> nÃ£o
faria nada diferente de uma cÃ³pia rasa, por isso podemos deixÃ¡-lo de lado.</p>
<p>O Rust tem uma anotaÃ§Ã£o especial chamada de <em>trait</em> <code>Copy</code>, que podemos colocar
em tipos como nÃºmeros inteiros, que sÃ£o armazenados na pilha (falaremos mais
sobre traits no CapÃ­tulo 10). Se um tipo possui o trait <code>Copy</code>, uma variÃ¡vel
anterior vai continuar sendo utilizÃ¡vel depois de uma atribuiÃ§Ã£o. O Rust nÃ£o vai
nos deixar anotar um tipo com o trait <code>Copy</code> se este tipo, ou qualquer uma de
suas partes, tiver implementado o trait <code>Drop</code>. Se o tipo precisa que algo
especial aconteÃ§a quando o valor sair de escopo e hÃ¡ uma anotaÃ§Ã£o <code>Copy</code> neste
tipo, vamos ter um erro de compilaÃ§Ã£o. Para aprender sobre como inserir a
anotaÃ§Ã£o <code>Copy</code> ao seu tipo, veja o ApÃªndice C em Traits DerivÃ¡veis.</p>
<p>EntÃ£o quais tipos sÃ£o <code>Copy</code>? VocÃª pode verificar a documentaÃ§Ã£o de um
determinado tipo para se certificar, mas como regra geral, qualquer grupo de
valores simples escalares podem ser <code>Copy</code>, e nada que precise de alocaÃ§Ã£o ou
que seja uma forma de recurso Ã© <code>Copy</code>. Aqui estÃ£o alguns tipos que sÃ£o <code>Copy</code>:</p>
<ul>
<li>Todos os tipos inteiros, como <code>u32</code>.</li>
<li>O tipo booleano, <code>bool</code>, com valores <code>true</code> e <code>false</code>.</li>
<li>O tipo caractere, <code>char</code>.</li>
<li>Todos os tipos de ponto flutuante, como <code>f64</code>.</li>
<li>Tuplas, mas apenas aquelas que contÃ©m tipos que tambÃ©m sÃ£o <code>Copy</code>.
<code>(i32, i32)</code> Ã© <code>Copy</code>, mas <code>(i32, String)</code> nÃ£o.</li>
</ul>
<h3><a class="header" href="#ownership-e-funÃ§Ãµes" id="ownership-e-funÃ§Ãµes">Ownership e FunÃ§Ãµes</a></h3>
<p>A semÃ¢ntica para passar um valor a uma funÃ§Ã£o Ã© similar Ã  de atribuir um valor
a uma variÃ¡vel. Passar uma variÃ¡vel a uma funÃ§Ã£o irÃ¡ mover ou copiar, assim como
acontece em uma atribuiÃ§Ã£o. A Listagem 4-3 tem um exemplo com algumas anotaÃ§Ãµes
mostrando onde as variÃ¡veis entram e saem de escopo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;texto&quot;);  // s entra em escopo.

    toma_posse(s);                  // move o valor de s para dentro da funÃ§Ã£o...
                                    // ... e ele nÃ£o Ã© mais vÃ¡lido aqui.

    let x = 5;                      // x entra em escopo.

    faz_uma_copia(x);               // x seria movido para dentro da funÃ§Ã£o,
                                    // mas i32 Ã© Copy, entÃ£o estÃ¡ tudo bem em
                                    // usar x daqui para a frente.

} // Aqui, x sai de escopo, e depois s. Mas como o valor de s foi movido, nada
  // de especial acontece.

fn toma_posse(uma_string: String) { // uma_string entra em escopo.
    println!(&quot;{}&quot;, uma_string);
} // Aqui, uma_string sai de escopo, e o mÃ©todo `drop` Ã© chamado. A memÃ³ria que
  // guarda seus dados Ã© liberada.

fn faz_uma_copia(um_inteiro: i32) { // um_inteiro entra em escopo.
    println!(&quot;{}&quot;, um_inteiro);
} // Aqui, um_inteiro sai de escopo. Nada de especial acontece.
</code></pre></pre>
<p><span class="caption">Listagem 4-3: FunÃ§Ãµes com anotaÃ§Ãµes de ownership e
escopo</span></p>
<p>Se tentÃ¡ssemos usar <code>s</code> apÃ³s a chamada para <code>toma_posse</code>, o Rust iria lanÃ§ar um
erro de compilaÃ§Ã£o. Essas verificaÃ§Ãµes estÃ¡ticas nos protegem de certo enganos.
Tente adicionar um cÃ³digo Ã  funÃ§Ã£o <code>main</code> que usa <code>s</code> e <code>x</code> para ver onde vocÃª
pode usÃ¡-los e onde as regras de ownership lhe impedem de fazÃª-lo.</p>
<h3><a class="header" href="#retorno-de-valores-e-escopo" id="retorno-de-valores-e-escopo">Retorno de Valores e Escopo</a></h3>
<p>Retornar valores tambÃ©m pode transferir a posse de um valor. Aqui estÃ¡ um
exemplo com anotaÃ§Ãµes similares Ã quelas da Listagem 4-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = entrega_valor();           // entrega_valor move o valor retornado
                                        // para s1.

    let s2 = String::from(&quot;texto&quot;);     // s2 entra em escopo.

    let s3 = pega_e_entrega_valor(s2);  // s2 Ã© movido para dentro da funÃ§Ã£o
                                        // pega_e_entrega_valor, que tambÃ©m
                                        // move o valor retornado para s3.
} // Aqui, s3 sai de escopo e Ã© destruÃ­da. s2 sai de escopo, mas jÃ¡ foi movida,
  // entÃ£o nada demais acontece. s1 sai de escopo e Ã© destruÃ­da.

fn entrega_valor() -&gt; String {               // entrega_valor move o valor
                                             // retornado para dentro da funÃ§Ã£o
                                             // que a chamou.

    let uma_string = String::from(&quot;olÃ¡&quot;);    // uma_string entra em escopo.

    uma_string                               // uma_string Ã© retornada e movida
                                             // para a funÃ§Ã£o que chamou
                                             // entrega_valor.
}

// pega_e_entrega_valor vai pegar uma String e retornÃ¡-la.
fn pega_e_entrega_valor(uma_string: String) -&gt; String { // uma_string entra em
                                                        // escopo.

    uma_string  // uma_string Ã© retornada e movida para a funÃ§Ã£o que chamou
                // pega_e_entrega_valor.
}
</code></pre></pre>
<p>A posse de uma variÃ¡vel segue o mesmo padrÃ£o toda vez: atribuir um valor a outra
variÃ¡vel irÃ¡ movÃª-lo. Quando uma variÃ¡vel que inclui dados na heap sai de
escopo, o valor serÃ¡ destruÃ­do pelo mÃ©todo <code>drop</code>, a nÃ£o ser que os dados tenham
sido movidos para outra variÃ¡vel.</p>
<p>Obter e retornar a posse de um valor em cada funÃ§Ã£o Ã© um pouco tedioso. O que
fazer se queremos deixar uma funÃ§Ã£o usar um valor sem tomar posse dele? Ã‰ meio
irritante saber que qualquer coisa que passemos a uma funÃ§Ã£o tambÃ©m precisa ser
passado de volta se quisermos usÃ¡-lo novamente, alÃ©m de algum possÃ­vel resultado
proveniente do corpo da funÃ§Ã£o que tambÃ©m queremos retornar.</p>
<p>Ã‰ possÃ­vel retornar mÃºltiplos valores usando uma tupla, da seguinte forma:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;texto&quot;);

    let (s2, tamanho) = calcula_tamanho(s1);

    println!(&quot;O tamanho de '{}' Ã© {}.&quot;, s2, tamanho);
}

fn calcula_tamanho(s: String) -&gt; (String, usize) {
    let tamanho = s.len(); // len() retorna o tamanho de uma String.

    (s, tamanho)
}
</code></pre></pre>
<p>Mas isto Ã© muita cerimÃ´nia e trabalho para um conceito que deveria ser comum.
Para nossa sorte, Rust tem uma ferramenta para este conceito, e ela Ã© chamada de
<em>referÃªncias</em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch04-00-understanding-ownership.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch04-02-references-and-borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch04-00-understanding-ownership.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch04-02-references-and-borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
